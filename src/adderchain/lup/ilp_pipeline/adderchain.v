//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 4.0 (http://legup.org)
// Compiled: Mon Jun  4 15:32:40 2018
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Mon Jun 25 17:11:00 2018
//----------------------------------------------------------------------------//

`define MEMORY_CONTROLLER_ADDR_SIZE 32
`define MEMORY_CONTROLLER_DATA_SIZE 64
// Number of RAM elements: 13
`define MEMORY_CONTROLLER_TAG_SIZE 9
// @aa = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
`define TAG_g_aa `MEMORY_CONTROLLER_TAG_SIZE'd11
`define TAG_g_aa_a {`TAG_g_aa, 23'd0}
// @b = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_b `MEMORY_CONTROLLER_TAG_SIZE'd2
`define TAG_g_b_a {`TAG_g_b, 23'd0}
// @bb = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
`define TAG_g_bb `MEMORY_CONTROLLER_TAG_SIZE'd12
`define TAG_g_bb_a {`TAG_g_bb, 23'd0}
// @c = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_c `MEMORY_CONTROLLER_TAG_SIZE'd3
`define TAG_g_c_a {`TAG_g_c, 23'd0}
// @cc = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
`define TAG_g_cc `MEMORY_CONTROLLER_TAG_SIZE'd13
`define TAG_g_cc_a {`TAG_g_cc, 23'd0}
// @d = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_d `MEMORY_CONTROLLER_TAG_SIZE'd4
`define TAG_g_d_a {`TAG_g_d, 23'd0}
// @dd = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
`define TAG_g_dd `MEMORY_CONTROLLER_TAG_SIZE'd14
`define TAG_g_dd_a {`TAG_g_dd, 23'd0}
// @e = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_e `MEMORY_CONTROLLER_TAG_SIZE'd5
`define TAG_g_e_a {`TAG_g_e, 23'd0}
// @f = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_f `MEMORY_CONTROLLER_TAG_SIZE'd6
`define TAG_g_f_a {`TAG_g_f, 23'd0}
// @g = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_g `MEMORY_CONTROLLER_TAG_SIZE'd7
`define TAG_g_g_a {`TAG_g_g, 23'd0}
// @h = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_h `MEMORY_CONTROLLER_TAG_SIZE'd8
`define TAG_g_h_a {`TAG_g_h, 23'd0}
// @ii = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
`define TAG_g_ii `MEMORY_CONTROLLER_TAG_SIZE'd9
`define TAG_g_ii_a {`TAG_g_ii, 23'd0}
// @j = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
`define TAG_g_j `MEMORY_CONTROLLER_TAG_SIZE'd10
`define TAG_g_j_a {`TAG_g_j, 23'd0}

// Turn off warning 'ignoring unsupported system task'
// altera message_off 10175

`timescale 1 ns / 1 ns
module top
	(
		clk,
		reset,
		start,
		finish,
		waitrequest,
		return_val
	);
input clk;
input reset;
input start;
output wire finish;
input waitrequest;
output wire [31:0] return_val;
wire memory_controller_waitrequest;
wire memory_controller_enable_a;
wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_a;
wire memory_controller_write_enable_a;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_a;
wire [1:0] memory_controller_size_a;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_a;

wire memory_controller_enable_b;
wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_b;
wire memory_controller_write_enable_b;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_b;
wire [1:0] memory_controller_size_b;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_b;

/* synthesis translate_off */
assign memory_controller_waitrequest = waitrequest;
/* synthesis translate_on */

memory_controller memory_controller_inst (
	.clk( clk ),
	.memory_controller_enable_a( memory_controller_enable_a ),
	.memory_controller_enable_b( memory_controller_enable_b ),
	.memory_controller_address_a( memory_controller_address_a ),
	.memory_controller_address_b( memory_controller_address_b ),
	.memory_controller_write_enable_a( memory_controller_write_enable_a ),
	.memory_controller_write_enable_b( memory_controller_write_enable_b ),
	.memory_controller_in_a( memory_controller_in_a ),
	.memory_controller_in_b( memory_controller_in_b ),
	.memory_controller_size_a( memory_controller_size_a ),
	.memory_controller_size_b( memory_controller_size_b ),
	.memory_controller_waitrequest( memory_controller_waitrequest ),
	.memory_controller_out_reg_a( memory_controller_out_a ),
	.memory_controller_out_reg_b( memory_controller_out_b )
);

main main_inst(
	.clk( clk ),
	.clk2x( clk2x ),
	.clk1x_follower( clk1x_follower ),
	.reset( reset ),
	.start( start ),
	.finish( finish ),
	.return_val( return_val ),
	.memory_controller_waitrequest(memory_controller_waitrequest),
	.memory_controller_enable_a(memory_controller_enable_a),
	.memory_controller_address_a(memory_controller_address_a),
	.memory_controller_write_enable_a(memory_controller_write_enable_a),
	.memory_controller_in_a(memory_controller_in_a),
	.memory_controller_size_a(memory_controller_size_a),
	.memory_controller_out_a(memory_controller_out_a),
	.memory_controller_enable_b(memory_controller_enable_b),
	.memory_controller_address_b(memory_controller_address_b),
	.memory_controller_write_enable_b(memory_controller_write_enable_b),
	.memory_controller_in_b(memory_controller_in_b),
	.memory_controller_size_b(memory_controller_size_b),
	.memory_controller_out_b(memory_controller_out_b)
);

endmodule

`timescale 1 ns / 1 ns
module memory_controller
(
	clk,
	memory_controller_address_a,
	memory_controller_address_b,
	memory_controller_enable_a,
	memory_controller_enable_b,
	memory_controller_write_enable_a,
	memory_controller_write_enable_b,
	memory_controller_in_a,
	memory_controller_in_b,
	memory_controller_size_a,
	memory_controller_size_b,
	memory_controller_waitrequest,
	memory_controller_out_reg_a,
	memory_controller_out_reg_b
);

parameter latency = 2;

parameter ram_latency = latency-1;

integer j;

input clk;
input memory_controller_waitrequest;
input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_a;
input memory_controller_enable_a;
input memory_controller_write_enable_a;
input [64-1:0] memory_controller_in_a;
input [1:0] memory_controller_size_a;
output reg [64-1:0] memory_controller_out_reg_a;
reg [64-1:0] memory_controller_out_prev_a;
reg [64-1:0] memory_controller_out_a;

reg memory_controller_enable_reg_a;
input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_b;
input memory_controller_enable_b;
input memory_controller_write_enable_b;
input [64-1:0] memory_controller_in_b;
input [1:0] memory_controller_size_b;
output reg [64-1:0] memory_controller_out_reg_b;
reg [64-1:0] memory_controller_out_prev_b;
reg [64-1:0] memory_controller_out_b;

reg memory_controller_enable_reg_b;

reg [6:0] b_address_a;
reg [6:0] b_address_b;
reg b_write_enable_a;
reg b_write_enable_b;
reg [31:0] b_in_a;
reg [31:0] b_in_b;
wire [31:0] b_out_a;
wire [31:0] b_out_b;

// @b = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port b (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( b_address_a ),
	.address_b( b_address_b ),
	.wren_a( b_write_enable_a ),
	.wren_b( b_write_enable_b ),
	.data_a( b_in_a ),
	.data_b( b_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( b_out_a ),
	.q_b( b_out_b)
);
defparam b.width_a = 32;
defparam b.width_b = 32;
defparam b.widthad_a = 7;
defparam b.widthad_b = 7;
defparam b.width_be_a = 1;
defparam b.width_be_b = 1;
defparam b.numwords_a = 100;
defparam b.numwords_b = 100;
defparam b.latency = ram_latency;
defparam b.init_file = "b.mif";

reg [6:0] c_address_a;
reg [6:0] c_address_b;
reg c_write_enable_a;
reg c_write_enable_b;
reg [31:0] c_in_a;
reg [31:0] c_in_b;
wire [31:0] c_out_a;
wire [31:0] c_out_b;

// @c = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port c (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( c_address_a ),
	.address_b( c_address_b ),
	.wren_a( c_write_enable_a ),
	.wren_b( c_write_enable_b ),
	.data_a( c_in_a ),
	.data_b( c_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( c_out_a ),
	.q_b( c_out_b)
);
defparam c.width_a = 32;
defparam c.width_b = 32;
defparam c.widthad_a = 7;
defparam c.widthad_b = 7;
defparam c.width_be_a = 1;
defparam c.width_be_b = 1;
defparam c.numwords_a = 100;
defparam c.numwords_b = 100;
defparam c.latency = ram_latency;
defparam c.init_file = "c.mif";

reg [6:0] d_address_a;
reg [6:0] d_address_b;
reg d_write_enable_a;
reg d_write_enable_b;
reg [31:0] d_in_a;
reg [31:0] d_in_b;
wire [31:0] d_out_a;
wire [31:0] d_out_b;

// @d = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port d (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( d_address_a ),
	.address_b( d_address_b ),
	.wren_a( d_write_enable_a ),
	.wren_b( d_write_enable_b ),
	.data_a( d_in_a ),
	.data_b( d_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( d_out_a ),
	.q_b( d_out_b)
);
defparam d.width_a = 32;
defparam d.width_b = 32;
defparam d.widthad_a = 7;
defparam d.widthad_b = 7;
defparam d.width_be_a = 1;
defparam d.width_be_b = 1;
defparam d.numwords_a = 100;
defparam d.numwords_b = 100;
defparam d.latency = ram_latency;
defparam d.init_file = "d.mif";

reg [6:0] e_address_a;
reg [6:0] e_address_b;
reg e_write_enable_a;
reg e_write_enable_b;
reg [31:0] e_in_a;
reg [31:0] e_in_b;
wire [31:0] e_out_a;
wire [31:0] e_out_b;

// @e = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port e (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( e_address_a ),
	.address_b( e_address_b ),
	.wren_a( e_write_enable_a ),
	.wren_b( e_write_enable_b ),
	.data_a( e_in_a ),
	.data_b( e_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( e_out_a ),
	.q_b( e_out_b)
);
defparam e.width_a = 32;
defparam e.width_b = 32;
defparam e.widthad_a = 7;
defparam e.widthad_b = 7;
defparam e.width_be_a = 1;
defparam e.width_be_b = 1;
defparam e.numwords_a = 100;
defparam e.numwords_b = 100;
defparam e.latency = ram_latency;
defparam e.init_file = "e.mif";

reg [6:0] f_address_a;
reg [6:0] f_address_b;
reg f_write_enable_a;
reg f_write_enable_b;
reg [31:0] f_in_a;
reg [31:0] f_in_b;
wire [31:0] f_out_a;
wire [31:0] f_out_b;

// @f = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port f (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( f_address_a ),
	.address_b( f_address_b ),
	.wren_a( f_write_enable_a ),
	.wren_b( f_write_enable_b ),
	.data_a( f_in_a ),
	.data_b( f_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( f_out_a ),
	.q_b( f_out_b)
);
defparam f.width_a = 32;
defparam f.width_b = 32;
defparam f.widthad_a = 7;
defparam f.widthad_b = 7;
defparam f.width_be_a = 1;
defparam f.width_be_b = 1;
defparam f.numwords_a = 100;
defparam f.numwords_b = 100;
defparam f.latency = ram_latency;
defparam f.init_file = "f.mif";

reg [6:0] g_address_a;
reg [6:0] g_address_b;
reg g_write_enable_a;
reg g_write_enable_b;
reg [31:0] g_in_a;
reg [31:0] g_in_b;
wire [31:0] g_out_a;
wire [31:0] g_out_b;

// @g = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port g (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( g_address_a ),
	.address_b( g_address_b ),
	.wren_a( g_write_enable_a ),
	.wren_b( g_write_enable_b ),
	.data_a( g_in_a ),
	.data_b( g_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( g_out_a ),
	.q_b( g_out_b)
);
defparam g.width_a = 32;
defparam g.width_b = 32;
defparam g.widthad_a = 7;
defparam g.widthad_b = 7;
defparam g.width_be_a = 1;
defparam g.width_be_b = 1;
defparam g.numwords_a = 100;
defparam g.numwords_b = 100;
defparam g.latency = ram_latency;
defparam g.init_file = "g.mif";

reg [6:0] h_address_a;
reg [6:0] h_address_b;
reg h_write_enable_a;
reg h_write_enable_b;
reg [31:0] h_in_a;
reg [31:0] h_in_b;
wire [31:0] h_out_a;
wire [31:0] h_out_b;

// @h = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port h (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( h_address_a ),
	.address_b( h_address_b ),
	.wren_a( h_write_enable_a ),
	.wren_b( h_write_enable_b ),
	.data_a( h_in_a ),
	.data_b( h_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( h_out_a ),
	.q_b( h_out_b)
);
defparam h.width_a = 32;
defparam h.width_b = 32;
defparam h.widthad_a = 7;
defparam h.widthad_b = 7;
defparam h.width_be_a = 1;
defparam h.width_be_b = 1;
defparam h.numwords_a = 100;
defparam h.numwords_b = 100;
defparam h.latency = ram_latency;
defparam h.init_file = "h.mif";

reg [6:0] ii_address_a;
reg [6:0] ii_address_b;
reg ii_write_enable_a;
reg ii_write_enable_b;
reg [31:0] ii_in_a;
reg [31:0] ii_in_b;
wire [31:0] ii_out_a;
wire [31:0] ii_out_b;

// @ii = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
ram_dual_port ii (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( ii_address_a ),
	.address_b( ii_address_b ),
	.wren_a( ii_write_enable_a ),
	.wren_b( ii_write_enable_b ),
	.data_a( ii_in_a ),
	.data_b( ii_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( ii_out_a ),
	.q_b( ii_out_b)
);
defparam ii.width_a = 32;
defparam ii.width_b = 32;
defparam ii.widthad_a = 7;
defparam ii.widthad_b = 7;
defparam ii.width_be_a = 1;
defparam ii.width_be_b = 1;
defparam ii.numwords_a = 100;
defparam ii.numwords_b = 100;
defparam ii.latency = ram_latency;
defparam ii.init_file = "ii.mif";

reg [6:0] j_address_a;
reg [6:0] j_address_b;
reg j_write_enable_a;
reg j_write_enable_b;
reg [31:0] j_in_a;
reg [31:0] j_in_b;
wire [31:0] j_out_a;
wire [31:0] j_out_b;

// @j = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22,...
ram_dual_port j (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( j_address_a ),
	.address_b( j_address_b ),
	.wren_a( j_write_enable_a ),
	.wren_b( j_write_enable_b ),
	.data_a( j_in_a ),
	.data_b( j_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( j_out_a ),
	.q_b( j_out_b)
);
defparam j.width_a = 32;
defparam j.width_b = 32;
defparam j.widthad_a = 7;
defparam j.widthad_b = 7;
defparam j.width_be_a = 1;
defparam j.width_be_b = 1;
defparam j.numwords_a = 100;
defparam j.numwords_b = 100;
defparam j.latency = ram_latency;
defparam j.init_file = "j.mif";

reg [6:0] aa_address_a;
reg [6:0] aa_address_b;
reg aa_write_enable_a;
reg aa_write_enable_b;
reg [31:0] aa_in_a;
reg [31:0] aa_in_b;
wire [31:0] aa_out_a;
wire [31:0] aa_out_b;

// @aa = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
ram_dual_port aa (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( aa_address_a ),
	.address_b( aa_address_b ),
	.wren_a( aa_write_enable_a ),
	.wren_b( aa_write_enable_b ),
	.data_a( aa_in_a ),
	.data_b( aa_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( aa_out_a ),
	.q_b( aa_out_b)
);
defparam aa.width_a = 32;
defparam aa.width_b = 32;
defparam aa.widthad_a = 7;
defparam aa.widthad_b = 7;
defparam aa.width_be_a = 1;
defparam aa.width_be_b = 1;
defparam aa.numwords_a = 100;
defparam aa.numwords_b = 100;
defparam aa.latency = ram_latency;
defparam aa.init_file = "aa.mif";

reg [6:0] bb_address_a;
reg [6:0] bb_address_b;
reg bb_write_enable_a;
reg bb_write_enable_b;
reg [31:0] bb_in_a;
reg [31:0] bb_in_b;
wire [31:0] bb_out_a;
wire [31:0] bb_out_b;

// @bb = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
ram_dual_port bb (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( bb_address_a ),
	.address_b( bb_address_b ),
	.wren_a( bb_write_enable_a ),
	.wren_b( bb_write_enable_b ),
	.data_a( bb_in_a ),
	.data_b( bb_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( bb_out_a ),
	.q_b( bb_out_b)
);
defparam bb.width_a = 32;
defparam bb.width_b = 32;
defparam bb.widthad_a = 7;
defparam bb.widthad_b = 7;
defparam bb.width_be_a = 1;
defparam bb.width_be_b = 1;
defparam bb.numwords_a = 100;
defparam bb.numwords_b = 100;
defparam bb.latency = ram_latency;
defparam bb.init_file = "bb.mif";

reg [6:0] cc_address_a;
reg [6:0] cc_address_b;
reg cc_write_enable_a;
reg cc_write_enable_b;
reg [31:0] cc_in_a;
reg [31:0] cc_in_b;
wire [31:0] cc_out_a;
wire [31:0] cc_out_b;

// @cc = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
ram_dual_port cc (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( cc_address_a ),
	.address_b( cc_address_b ),
	.wren_a( cc_write_enable_a ),
	.wren_b( cc_write_enable_b ),
	.data_a( cc_in_a ),
	.data_b( cc_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( cc_out_a ),
	.q_b( cc_out_b)
);
defparam cc.width_a = 32;
defparam cc.width_b = 32;
defparam cc.widthad_a = 7;
defparam cc.widthad_b = 7;
defparam cc.width_be_a = 1;
defparam cc.width_be_b = 1;
defparam cc.numwords_a = 100;
defparam cc.numwords_b = 100;
defparam cc.latency = ram_latency;
defparam cc.init_file = "cc.mif";

reg [6:0] dd_address_a;
reg [6:0] dd_address_b;
reg dd_write_enable_a;
reg dd_write_enable_b;
reg [31:0] dd_in_a;
reg [31:0] dd_in_b;
wire [31:0] dd_out_a;
wire [31:0] dd_out_b;

// @dd = internal global [100 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22...
ram_dual_port dd (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( dd_address_a ),
	.address_b( dd_address_b ),
	.wren_a( dd_write_enable_a ),
	.wren_b( dd_write_enable_b ),
	.data_a( dd_in_a ),
	.data_b( dd_in_b ),
	.byteena_a( 1'b1 ),
	.byteena_b( 1'b1 ),
	.q_a( dd_out_a ),
	.q_b( dd_out_b)
);
defparam dd.width_a = 32;
defparam dd.width_b = 32;
defparam dd.widthad_a = 7;
defparam dd.widthad_b = 7;
defparam dd.width_be_a = 1;
defparam dd.width_be_b = 1;
defparam dd.numwords_a = 100;
defparam dd.numwords_b = 100;
defparam dd.latency = ram_latency;
defparam dd.init_file = "dd.mif";
wire [`MEMORY_CONTROLLER_TAG_SIZE-1:0] tag_a;
assign tag_a = memory_controller_address_a[`MEMORY_CONTROLLER_ADDR_SIZE-1:`MEMORY_CONTROLLER_ADDR_SIZE-`MEMORY_CONTROLLER_TAG_SIZE];
reg [2:0] prevAddr_a;
reg [1:0] prevSize_a;
reg [2:0] prevSize_a_and;

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
	prevAddr_a <= memory_controller_address_a[2:0];
	prevSize_a <= memory_controller_size_a;
end
wire [`MEMORY_CONTROLLER_TAG_SIZE-1:0] tag_b;
assign tag_b = memory_controller_address_b[`MEMORY_CONTROLLER_ADDR_SIZE-1:`MEMORY_CONTROLLER_ADDR_SIZE-`MEMORY_CONTROLLER_TAG_SIZE];
reg [2:0] prevAddr_b;
reg [1:0] prevSize_b;
reg [2:0] prevSize_b_and;

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
	prevAddr_b <= memory_controller_address_b[2:0];
	prevSize_b <= memory_controller_size_b;
end

reg [2:0] select_not_struct_a;

wire select_b_a;
assign select_b_a = (tag_a == `TAG_g_b);
reg [ram_latency:0] select_b_reg_a;
wire [31:0] memory_controller_b_out_a;
assign memory_controller_b_out_a = {32{ select_b_reg_a[ram_latency]}} & b_out_a;

wire select_c_a;
assign select_c_a = (tag_a == `TAG_g_c);
reg [ram_latency:0] select_c_reg_a;
wire [31:0] memory_controller_c_out_a;
assign memory_controller_c_out_a = {32{ select_c_reg_a[ram_latency]}} & c_out_a;

wire select_d_a;
assign select_d_a = (tag_a == `TAG_g_d);
reg [ram_latency:0] select_d_reg_a;
wire [31:0] memory_controller_d_out_a;
assign memory_controller_d_out_a = {32{ select_d_reg_a[ram_latency]}} & d_out_a;

wire select_e_a;
assign select_e_a = (tag_a == `TAG_g_e);
reg [ram_latency:0] select_e_reg_a;
wire [31:0] memory_controller_e_out_a;
assign memory_controller_e_out_a = {32{ select_e_reg_a[ram_latency]}} & e_out_a;

wire select_f_a;
assign select_f_a = (tag_a == `TAG_g_f);
reg [ram_latency:0] select_f_reg_a;
wire [31:0] memory_controller_f_out_a;
assign memory_controller_f_out_a = {32{ select_f_reg_a[ram_latency]}} & f_out_a;

wire select_g_a;
assign select_g_a = (tag_a == `TAG_g_g);
reg [ram_latency:0] select_g_reg_a;
wire [31:0] memory_controller_g_out_a;
assign memory_controller_g_out_a = {32{ select_g_reg_a[ram_latency]}} & g_out_a;

wire select_h_a;
assign select_h_a = (tag_a == `TAG_g_h);
reg [ram_latency:0] select_h_reg_a;
wire [31:0] memory_controller_h_out_a;
assign memory_controller_h_out_a = {32{ select_h_reg_a[ram_latency]}} & h_out_a;

wire select_ii_a;
assign select_ii_a = (tag_a == `TAG_g_ii);
reg [ram_latency:0] select_ii_reg_a;
wire [31:0] memory_controller_ii_out_a;
assign memory_controller_ii_out_a = {32{ select_ii_reg_a[ram_latency]}} & ii_out_a;

wire select_j_a;
assign select_j_a = (tag_a == `TAG_g_j);
reg [ram_latency:0] select_j_reg_a;
wire [31:0] memory_controller_j_out_a;
assign memory_controller_j_out_a = {32{ select_j_reg_a[ram_latency]}} & j_out_a;

wire select_aa_a;
assign select_aa_a = (tag_a == `TAG_g_aa);
reg [ram_latency:0] select_aa_reg_a;
wire [31:0] memory_controller_aa_out_a;
assign memory_controller_aa_out_a = {32{ select_aa_reg_a[ram_latency]}} & aa_out_a;

wire select_bb_a;
assign select_bb_a = (tag_a == `TAG_g_bb);
reg [ram_latency:0] select_bb_reg_a;
wire [31:0] memory_controller_bb_out_a;
assign memory_controller_bb_out_a = {32{ select_bb_reg_a[ram_latency]}} & bb_out_a;

wire select_cc_a;
assign select_cc_a = (tag_a == `TAG_g_cc);
reg [ram_latency:0] select_cc_reg_a;
wire [31:0] memory_controller_cc_out_a;
assign memory_controller_cc_out_a = {32{ select_cc_reg_a[ram_latency]}} & cc_out_a;

wire select_dd_a;
assign select_dd_a = (tag_a == `TAG_g_dd);
reg [ram_latency:0] select_dd_reg_a;
wire [31:0] memory_controller_dd_out_a;
assign memory_controller_dd_out_a = {32{ select_dd_reg_a[ram_latency]}} & dd_out_a;

always @(*)
begin
	b_address_a = memory_controller_address_a [7-1+2:2] & {7{select_b_a}};
	b_write_enable_a = memory_controller_write_enable_a & select_b_a;
	b_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	c_address_a = memory_controller_address_a [7-1+2:2] & {7{select_c_a}};
	c_write_enable_a = memory_controller_write_enable_a & select_c_a;
	c_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	d_address_a = memory_controller_address_a [7-1+2:2] & {7{select_d_a}};
	d_write_enable_a = memory_controller_write_enable_a & select_d_a;
	d_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	e_address_a = memory_controller_address_a [7-1+2:2] & {7{select_e_a}};
	e_write_enable_a = memory_controller_write_enable_a & select_e_a;
	e_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	f_address_a = memory_controller_address_a [7-1+2:2] & {7{select_f_a}};
	f_write_enable_a = memory_controller_write_enable_a & select_f_a;
	f_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	g_address_a = memory_controller_address_a [7-1+2:2] & {7{select_g_a}};
	g_write_enable_a = memory_controller_write_enable_a & select_g_a;
	g_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	h_address_a = memory_controller_address_a [7-1+2:2] & {7{select_h_a}};
	h_write_enable_a = memory_controller_write_enable_a & select_h_a;
	h_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	ii_address_a = memory_controller_address_a [7-1+2:2] & {7{select_ii_a}};
	ii_write_enable_a = memory_controller_write_enable_a & select_ii_a;
	ii_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	j_address_a = memory_controller_address_a [7-1+2:2] & {7{select_j_a}};
	j_write_enable_a = memory_controller_write_enable_a & select_j_a;
	j_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	aa_address_a = memory_controller_address_a [7-1+2:2] & {7{select_aa_a}};
	aa_write_enable_a = memory_controller_write_enable_a & select_aa_a;
	aa_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	bb_address_a = memory_controller_address_a [7-1+2:2] & {7{select_bb_a}};
	bb_write_enable_a = memory_controller_write_enable_a & select_bb_a;
	bb_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	cc_address_a = memory_controller_address_a [7-1+2:2] & {7{select_cc_a}};
	cc_write_enable_a = memory_controller_write_enable_a & select_cc_a;
	cc_in_a [32-1:0] = memory_controller_in_a[32-1:0];

	dd_address_a = memory_controller_address_a [7-1+2:2] & {7{select_dd_a}};
	dd_write_enable_a = memory_controller_write_enable_a & select_dd_a;
	dd_in_a [32-1:0] = memory_controller_in_a[32-1:0];

end
always @(*)
begin
	select_not_struct_a [2:0] = 3'b0 | {2{select_b_reg_a[ram_latency]}} | {2{select_c_reg_a[ram_latency]}} | {2{select_d_reg_a[ram_latency]}} | {2{select_e_reg_a[ram_latency]}} | {2{select_f_reg_a[ram_latency]}} | {2{select_g_reg_a[ram_latency]}} | {2{select_h_reg_a[ram_latency]}} | {2{select_ii_reg_a[ram_latency]}} | {2{select_j_reg_a[ram_latency]}} | {2{select_aa_reg_a[ram_latency]}} | {2{select_bb_reg_a[ram_latency]}} | {2{select_cc_reg_a[ram_latency]}} | {2{select_dd_reg_a[ram_latency]}};
	if (prevAddr_a[2:0] & select_not_struct_a[2:0] != 0 && memory_controller_enable_a)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end

	prevSize_a_and[0] = prevSize_a[1] | prevSize_a[0];
	prevSize_a_and[1] = prevSize_a[1];
	prevSize_a_and[2] = prevSize_a[1] & prevSize_a[0];
	if ((prevAddr_a & prevSize_a_and) != 0 && memory_controller_enable_a)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end
	memory_controller_out_prev_a = memory_controller_out_reg_a & { 64{!memory_controller_enable_reg_a}};
	memory_controller_out_a = 1'b0 | memory_controller_out_prev_a | memory_controller_b_out_a | memory_controller_c_out_a | memory_controller_d_out_a | memory_controller_e_out_a | memory_controller_f_out_a | memory_controller_g_out_a | memory_controller_h_out_a | memory_controller_ii_out_a | memory_controller_j_out_a | memory_controller_aa_out_a | memory_controller_bb_out_a | memory_controller_cc_out_a | memory_controller_dd_out_a;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
memory_controller_out_reg_a <= memory_controller_out_a;
memory_controller_enable_reg_a <= memory_controller_enable_a;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
for (j = 0; j < ram_latency; j=j+1)
begin
select_b_reg_a[j+1] <= select_b_reg_a[j];
select_c_reg_a[j+1] <= select_c_reg_a[j];
select_d_reg_a[j+1] <= select_d_reg_a[j];
select_e_reg_a[j+1] <= select_e_reg_a[j];
select_f_reg_a[j+1] <= select_f_reg_a[j];
select_g_reg_a[j+1] <= select_g_reg_a[j];
select_h_reg_a[j+1] <= select_h_reg_a[j];
select_ii_reg_a[j+1] <= select_ii_reg_a[j];
select_j_reg_a[j+1] <= select_j_reg_a[j];
select_aa_reg_a[j+1] <= select_aa_reg_a[j];
select_bb_reg_a[j+1] <= select_bb_reg_a[j];
select_cc_reg_a[j+1] <= select_cc_reg_a[j];
select_dd_reg_a[j+1] <= select_dd_reg_a[j];
end
always @(*)
begin
select_b_reg_a[0] <= select_b_a;
select_c_reg_a[0] <= select_c_a;
select_d_reg_a[0] <= select_d_a;
select_e_reg_a[0] <= select_e_a;
select_f_reg_a[0] <= select_f_a;
select_g_reg_a[0] <= select_g_a;
select_h_reg_a[0] <= select_h_a;
select_ii_reg_a[0] <= select_ii_a;
select_j_reg_a[0] <= select_j_a;
select_aa_reg_a[0] <= select_aa_a;
select_bb_reg_a[0] <= select_bb_a;
select_cc_reg_a[0] <= select_cc_a;
select_dd_reg_a[0] <= select_dd_a;
end

reg [2:0] select_not_struct_b;

wire select_b_b;
assign select_b_b = (tag_b == `TAG_g_b);
reg [ram_latency:0] select_b_reg_b;
wire [31:0] memory_controller_b_out_b;
assign memory_controller_b_out_b = {32{ select_b_reg_b[ram_latency]}} & b_out_b;

wire select_c_b;
assign select_c_b = (tag_b == `TAG_g_c);
reg [ram_latency:0] select_c_reg_b;
wire [31:0] memory_controller_c_out_b;
assign memory_controller_c_out_b = {32{ select_c_reg_b[ram_latency]}} & c_out_b;

wire select_d_b;
assign select_d_b = (tag_b == `TAG_g_d);
reg [ram_latency:0] select_d_reg_b;
wire [31:0] memory_controller_d_out_b;
assign memory_controller_d_out_b = {32{ select_d_reg_b[ram_latency]}} & d_out_b;

wire select_e_b;
assign select_e_b = (tag_b == `TAG_g_e);
reg [ram_latency:0] select_e_reg_b;
wire [31:0] memory_controller_e_out_b;
assign memory_controller_e_out_b = {32{ select_e_reg_b[ram_latency]}} & e_out_b;

wire select_f_b;
assign select_f_b = (tag_b == `TAG_g_f);
reg [ram_latency:0] select_f_reg_b;
wire [31:0] memory_controller_f_out_b;
assign memory_controller_f_out_b = {32{ select_f_reg_b[ram_latency]}} & f_out_b;

wire select_g_b;
assign select_g_b = (tag_b == `TAG_g_g);
reg [ram_latency:0] select_g_reg_b;
wire [31:0] memory_controller_g_out_b;
assign memory_controller_g_out_b = {32{ select_g_reg_b[ram_latency]}} & g_out_b;

wire select_h_b;
assign select_h_b = (tag_b == `TAG_g_h);
reg [ram_latency:0] select_h_reg_b;
wire [31:0] memory_controller_h_out_b;
assign memory_controller_h_out_b = {32{ select_h_reg_b[ram_latency]}} & h_out_b;

wire select_ii_b;
assign select_ii_b = (tag_b == `TAG_g_ii);
reg [ram_latency:0] select_ii_reg_b;
wire [31:0] memory_controller_ii_out_b;
assign memory_controller_ii_out_b = {32{ select_ii_reg_b[ram_latency]}} & ii_out_b;

wire select_j_b;
assign select_j_b = (tag_b == `TAG_g_j);
reg [ram_latency:0] select_j_reg_b;
wire [31:0] memory_controller_j_out_b;
assign memory_controller_j_out_b = {32{ select_j_reg_b[ram_latency]}} & j_out_b;

wire select_aa_b;
assign select_aa_b = (tag_b == `TAG_g_aa);
reg [ram_latency:0] select_aa_reg_b;
wire [31:0] memory_controller_aa_out_b;
assign memory_controller_aa_out_b = {32{ select_aa_reg_b[ram_latency]}} & aa_out_b;

wire select_bb_b;
assign select_bb_b = (tag_b == `TAG_g_bb);
reg [ram_latency:0] select_bb_reg_b;
wire [31:0] memory_controller_bb_out_b;
assign memory_controller_bb_out_b = {32{ select_bb_reg_b[ram_latency]}} & bb_out_b;

wire select_cc_b;
assign select_cc_b = (tag_b == `TAG_g_cc);
reg [ram_latency:0] select_cc_reg_b;
wire [31:0] memory_controller_cc_out_b;
assign memory_controller_cc_out_b = {32{ select_cc_reg_b[ram_latency]}} & cc_out_b;

wire select_dd_b;
assign select_dd_b = (tag_b == `TAG_g_dd);
reg [ram_latency:0] select_dd_reg_b;
wire [31:0] memory_controller_dd_out_b;
assign memory_controller_dd_out_b = {32{ select_dd_reg_b[ram_latency]}} & dd_out_b;

always @(*)
begin
	b_address_b = memory_controller_address_b [7-1+2:2] & {7{select_b_b}};
	b_write_enable_b = memory_controller_write_enable_b & select_b_b;
	b_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	c_address_b = memory_controller_address_b [7-1+2:2] & {7{select_c_b}};
	c_write_enable_b = memory_controller_write_enable_b & select_c_b;
	c_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	d_address_b = memory_controller_address_b [7-1+2:2] & {7{select_d_b}};
	d_write_enable_b = memory_controller_write_enable_b & select_d_b;
	d_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	e_address_b = memory_controller_address_b [7-1+2:2] & {7{select_e_b}};
	e_write_enable_b = memory_controller_write_enable_b & select_e_b;
	e_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	f_address_b = memory_controller_address_b [7-1+2:2] & {7{select_f_b}};
	f_write_enable_b = memory_controller_write_enable_b & select_f_b;
	f_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	g_address_b = memory_controller_address_b [7-1+2:2] & {7{select_g_b}};
	g_write_enable_b = memory_controller_write_enable_b & select_g_b;
	g_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	h_address_b = memory_controller_address_b [7-1+2:2] & {7{select_h_b}};
	h_write_enable_b = memory_controller_write_enable_b & select_h_b;
	h_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	ii_address_b = memory_controller_address_b [7-1+2:2] & {7{select_ii_b}};
	ii_write_enable_b = memory_controller_write_enable_b & select_ii_b;
	ii_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	j_address_b = memory_controller_address_b [7-1+2:2] & {7{select_j_b}};
	j_write_enable_b = memory_controller_write_enable_b & select_j_b;
	j_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	aa_address_b = memory_controller_address_b [7-1+2:2] & {7{select_aa_b}};
	aa_write_enable_b = memory_controller_write_enable_b & select_aa_b;
	aa_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	bb_address_b = memory_controller_address_b [7-1+2:2] & {7{select_bb_b}};
	bb_write_enable_b = memory_controller_write_enable_b & select_bb_b;
	bb_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	cc_address_b = memory_controller_address_b [7-1+2:2] & {7{select_cc_b}};
	cc_write_enable_b = memory_controller_write_enable_b & select_cc_b;
	cc_in_b [32-1:0] = memory_controller_in_b[32-1:0];

	dd_address_b = memory_controller_address_b [7-1+2:2] & {7{select_dd_b}};
	dd_write_enable_b = memory_controller_write_enable_b & select_dd_b;
	dd_in_b [32-1:0] = memory_controller_in_b[32-1:0];

end
always @(*)
begin
	select_not_struct_b [2:0] = 3'b0 | {2{select_b_reg_b[ram_latency]}} | {2{select_c_reg_b[ram_latency]}} | {2{select_d_reg_b[ram_latency]}} | {2{select_e_reg_b[ram_latency]}} | {2{select_f_reg_b[ram_latency]}} | {2{select_g_reg_b[ram_latency]}} | {2{select_h_reg_b[ram_latency]}} | {2{select_ii_reg_b[ram_latency]}} | {2{select_j_reg_b[ram_latency]}} | {2{select_aa_reg_b[ram_latency]}} | {2{select_bb_reg_b[ram_latency]}} | {2{select_cc_reg_b[ram_latency]}} | {2{select_dd_reg_b[ram_latency]}};
	if (prevAddr_b[2:0] & select_not_struct_b[2:0] != 0 && memory_controller_enable_b)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end

	prevSize_b_and[0] = prevSize_b[1] | prevSize_b[0];
	prevSize_b_and[1] = prevSize_b[1];
	prevSize_b_and[2] = prevSize_b[1] & prevSize_b[0];
	if ((prevAddr_b & prevSize_b_and) != 0 && memory_controller_enable_b)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end
	memory_controller_out_prev_b = memory_controller_out_reg_b & { 64{!memory_controller_enable_reg_b}};
	memory_controller_out_b = 1'b0 | memory_controller_out_prev_b | memory_controller_b_out_b | memory_controller_c_out_b | memory_controller_d_out_b | memory_controller_e_out_b | memory_controller_f_out_b | memory_controller_g_out_b | memory_controller_h_out_b | memory_controller_ii_out_b | memory_controller_j_out_b | memory_controller_aa_out_b | memory_controller_bb_out_b | memory_controller_cc_out_b | memory_controller_dd_out_b;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
memory_controller_out_reg_b <= memory_controller_out_b;
memory_controller_enable_reg_b <= memory_controller_enable_b;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
for (j = 0; j < ram_latency; j=j+1)
begin
select_b_reg_b[j+1] <= select_b_reg_b[j];
select_c_reg_b[j+1] <= select_c_reg_b[j];
select_d_reg_b[j+1] <= select_d_reg_b[j];
select_e_reg_b[j+1] <= select_e_reg_b[j];
select_f_reg_b[j+1] <= select_f_reg_b[j];
select_g_reg_b[j+1] <= select_g_reg_b[j];
select_h_reg_b[j+1] <= select_h_reg_b[j];
select_ii_reg_b[j+1] <= select_ii_reg_b[j];
select_j_reg_b[j+1] <= select_j_reg_b[j];
select_aa_reg_b[j+1] <= select_aa_reg_b[j];
select_bb_reg_b[j+1] <= select_bb_reg_b[j];
select_cc_reg_b[j+1] <= select_cc_reg_b[j];
select_dd_reg_b[j+1] <= select_dd_reg_b[j];
end
always @(*)
begin
select_b_reg_b[0] <= select_b_b;
select_c_reg_b[0] <= select_c_b;
select_d_reg_b[0] <= select_d_b;
select_e_reg_b[0] <= select_e_b;
select_f_reg_b[0] <= select_f_b;
select_g_reg_b[0] <= select_g_b;
select_h_reg_b[0] <= select_h_b;
select_ii_reg_b[0] <= select_ii_b;
select_j_reg_b[0] <= select_j_b;
select_aa_reg_b[0] <= select_aa_b;
select_bb_reg_b[0] <= select_bb_b;
select_cc_reg_b[0] <= select_cc_b;
select_dd_reg_b[0] <= select_dd_b;
end

endmodule 

`timescale 1 ns / 1 ns
module main
(
	clk,
	clk2x,
	clk1x_follower,
	reset,
	start,
	finish,
	memory_controller_waitrequest,
	memory_controller_enable_a,
	memory_controller_address_a,
	memory_controller_write_enable_a,
	memory_controller_in_a,
	memory_controller_size_a,
	memory_controller_out_a,
	memory_controller_enable_b,
	memory_controller_address_b,
	memory_controller_write_enable_b,
	memory_controller_in_b,
	memory_controller_size_b,
	memory_controller_out_b,
	return_val
);

parameter [2:0] LEGUP_0 = 3'd0;
parameter [2:0] LEGUP_loop_pipeline_wait_loop_1_1 = 3'd1;
parameter [2:0] LEGUP_F_main_BB__70_2 = 3'd2;
parameter [2:0] LEGUP_F_main_BB__70_3 = 3'd3;
parameter [2:0] LEGUP_F_main_BB__70_4 = 3'd4;
parameter [2:0] LEGUP_F_main_BB__74_5 = 3'd5;
parameter [2:0] LEGUP_F_main_BB__76_6 = 3'd6;
parameter [2:0] LEGUP_F_main_BB__78_7 = 3'd7;
parameter [8:0] tag_offset = 9'd0;
parameter [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] tag_addr_offset = {tag_offset, 23'd0};

input  clk;
input  clk2x;
input  clk1x_follower;
input  reset;
input  start;
output reg  finish;
input  memory_controller_waitrequest;
output reg  memory_controller_enable_a;
output reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_a;
output reg  memory_controller_write_enable_a;
output reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_a;
output reg [1:0] memory_controller_size_a;
input [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_a;
output reg  memory_controller_enable_b;
output reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_b;
output reg  memory_controller_write_enable_b;
output reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_b;
output reg [1:0] memory_controller_size_b;
input [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_b;
output reg [31:0] return_val;
reg [2:0] cur_state;
reg [2:0] next_state;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep2;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep3;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep4;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep5;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep6;
reg [31:0] main_1_2;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep7;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep8;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep9;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep10;
reg [31:0] main_1_3;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep11;
reg [31:0] main_1_4;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep12;
reg [31:0] main_1_5;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep13;
reg [31:0] main_1_6;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep14;
reg [31:0] main_1_7;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep15;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep16;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep17;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep18;
reg [31:0] main_1_8;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep19;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep20;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep21;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep22;
reg [31:0] main_1_9;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep23;
reg [31:0] main_1_10;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep24;
reg [31:0] main_1_11;
reg [31:0] main_1_12;
reg [31:0] main_1_13;
reg [31:0] main_1_14;
reg [31:0] main_1_15;
reg [31:0] main_1_16;
reg [31:0] main_1_17;
reg [31:0] main_1_18;
reg [31:0] main_1_19;
reg [31:0] main_1_21;
reg [31:0] main_1_22;
reg [31:0] main_1_23;
reg [31:0] main_1_24;
reg [31:0] main_1_25;
reg [31:0] main_1_26;
reg [31:0] main_1_27;
reg [31:0] main_1_28;
reg [31:0] main_1_29;
reg [31:0] main_1_30;
reg [31:0] main_1_31;
reg [31:0] main_1_32;
reg [31:0] main_1_33;
reg [31:0] main_1_34;
reg [31:0] main_1_35;
reg [31:0] main_1_36;
reg [31:0] main_1_37;
reg [31:0] main_1_38;
reg [31:0] main_1_39;
reg [31:0] main_1_40;
reg [31:0] main_1_41;
reg [31:0] main_1_42;
reg [31:0] main_1_43;
reg [31:0] main_1_44;
reg [31:0] main_1_45;
reg [31:0] main_1_46;
reg [31:0] main_1_47;
reg [31:0] main_1_48;
reg [31:0] main_1_49;
reg [31:0] main_1_50;
reg [31:0] main_1_51;
reg [31:0] main_1_52;
reg [31:0] main_1_53;
reg [31:0] main_1_54;
reg [31:0] main_1_55;
reg [31:0] main_1_56;
reg [31:0] main_1_57;
reg [31:0] main_1_58;
reg [31:0] main_1_59;
reg [31:0] main_1_60;
reg [31:0] main_1_61;
reg [31:0] main_1_62;
reg [31:0] main_1_63;
reg [31:0] main_1_64;
reg [31:0] main_1_65;
reg [31:0] main_1_66;
reg [31:0] main_1_67;
reg [31:0] main_1_68;
reg [31:0] main_1_69;
reg [31:0] main_70_71;
reg [31:0] main_70_71_reg;
reg  main_70_73;
reg  loop_1_pipeline_start;
reg  loop_1_started;
reg [3:0] loop_1_ii_state;
reg [31:0] loop_1_i_stage0;
reg  loop_1_epilogue;
reg  loop_1_valid_bit_0;
reg  loop_1_valid_bit_1;
reg  loop_1_valid_bit_2;
reg  loop_1_valid_bit_3;
reg  loop_1_valid_bit_4;
reg  loop_1_valid_bit_5;
reg  loop_1_valid_bit_6;
reg  loop_1_valid_bit_7;
reg  loop_1_valid_bit_8;
reg  loop_1_valid_bit_9;
reg  loop_1_valid_bit_10;
reg  loop_1_valid_bit_11;
reg  loop_1_valid_bit_12;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep2_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep3_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep4_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep5_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep6_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep7_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep8_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep9_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep10_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep11_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep12_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep13_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep14_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep15_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep16_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep17_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep18_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep19_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep20_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep21_reg_stage0;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep22_reg_stage0;
reg [31:0] main_1_15_reg_stage0;
reg [31:0] main_1_22_reg_stage0;
reg [31:0] main_1_31_reg_stage0;
reg [31:0] main_1_32_reg_stage0;
reg [31:0] main_1_35_reg_stage0;
reg [31:0] main_1_37_reg_stage0;
reg [31:0] main_1_38_reg_stage0;
reg [31:0] main_1_41_reg_stage0;
reg [31:0] main_1_43_reg_stage0;
reg [31:0] main_1_45_reg_stage0;
reg [31:0] main_1_47_reg_stage0;
reg [31:0] main_1_50_reg_stage0;
reg [31:0] main_1_51_reg_stage0;
reg [31:0] main_1_54_reg_stage0;
reg [31:0] main_1_56_reg_stage0;
reg [31:0] main_1_57_reg_stage0;
reg [31:0] main_1_60_reg_stage0;
reg [31:0] main_1_62_reg_stage0;
reg [31:0] main_1_64_reg_stage0;
reg [31:0] main_1_66_reg_stage0;
reg  loop_1_pipeline_exit_cond;
reg  loop_1_pipeline_finish;


/* Unsynthesizable Statements */
always @(posedge clk)
	if (!memory_controller_waitrequest) begin
	/* main: %70*/
	/*   %72 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([10 x i8]* @.str1, i32 0, i32 0), i32 %71) #2*/
	if ((cur_state == LEGUP_F_main_BB__70_4)) begin
		$write("sum = %d\n", $signed(main_70_71));
		// to fix quartus warning
		if (reset == 1'b0 && ^(main_70_71) === 1'bX) finish <= 0;
	end
	/* main: %74*/
	/*   %75 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([8 x i8]* @.str2, i32 0, i32 0)) #2*/
	if ((cur_state == LEGUP_F_main_BB__74_5)) begin
		$write("PASSED\n");
	end
	/* main: %76*/
	/*   %77 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([8 x i8]* @.str3, i32 0, i32 0)) #2*/
	if ((cur_state == LEGUP_F_main_BB__76_6)) begin
		$write("FAILED\n");
	end
end
always @(posedge clk) begin
if (reset == 1'b1)
	cur_state <= LEGUP_0;
else if (memory_controller_waitrequest == 1'd1)
	cur_state <= cur_state;
else
	cur_state <= next_state;
end

always @(*)
begin
next_state = cur_state;
case(cur_state)  // synthesis parallel_case  
LEGUP_0:
	if ((start == 1'd1))
		next_state = LEGUP_loop_pipeline_wait_loop_1_1;
LEGUP_F_main_BB__70_2:
		next_state = LEGUP_F_main_BB__70_3;
LEGUP_F_main_BB__70_3:
		next_state = LEGUP_F_main_BB__70_4;
LEGUP_F_main_BB__70_4:
	if ((main_70_73 == 1'd1))
		next_state = LEGUP_F_main_BB__74_5;
	else if ((main_70_73 == 1'd0))
		next_state = LEGUP_F_main_BB__76_6;
LEGUP_F_main_BB__74_5:
		next_state = LEGUP_F_main_BB__78_7;
LEGUP_F_main_BB__76_6:
		next_state = LEGUP_F_main_BB__78_7;
LEGUP_F_main_BB__78_7:
		next_state = LEGUP_0;
LEGUP_loop_pipeline_wait_loop_1_1:
	if ((loop_1_pipeline_finish == 1'd1))
		next_state = LEGUP_F_main_BB__70_2;
	else if ((loop_1_pipeline_finish == 1'd1))
		next_state = LEGUP_F_main_BB__70_2;
default:
	next_state = cur_state;
endcase

end
always @(*) begin
	/* main: %1*/
	/*   %scevgep = getelementptr [100 x i32]* @dd, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep = (`TAG_g_dd_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep2 = getelementptr [100 x i32]* @cc, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep2 = (`TAG_g_cc_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep3 = getelementptr [100 x i32]* @aa, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep3 = (`TAG_g_aa_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep4 = getelementptr [100 x i32]* @bb, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep4 = (`TAG_g_bb_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep5 = getelementptr [100 x i32]* @ii, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep5 = (`TAG_g_ii_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep6 = getelementptr [100 x i32]* @g, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep6 = (`TAG_g_g_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %2 = add i32 %i.01, 1, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_2 = (loop_1_i_stage0 + 32'd1);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep7 = getelementptr [100 x i32]* @dd, i32 0, i32 %2, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep7 = (`TAG_g_dd_a + (4 * main_1_2));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep8 = getelementptr [100 x i32]* @g, i32 0, i32 %2, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep8 = (`TAG_g_g_a + (4 * main_1_2));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep9 = getelementptr [100 x i32]* @e, i32 0, i32 %2, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep9 = (`TAG_g_e_a + (4 * main_1_2));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep10 = getelementptr [100 x i32]* @e, i32 0, i32 %i.01, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep10 = (`TAG_g_e_a + (4 * loop_1_i_stage0));
end
always @(*) begin
	/* main: %1*/
	/*   %3 = add i32 %i.01, 7, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_3 = (loop_1_i_stage0 + 32'd7);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep11 = getelementptr [100 x i32]* @d, i32 0, i32 %3, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep11 = (`TAG_g_d_a + (4 * main_1_3));
end
always @(*) begin
	/* main: %1*/
	/*   %4 = add i32 %i.01, 6, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_4 = (loop_1_i_stage0 + 32'd6);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep12 = getelementptr [100 x i32]* @d, i32 0, i32 %4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep12 = (`TAG_g_d_a + (4 * main_1_4));
end
always @(*) begin
	/* main: %1*/
	/*   %5 = add i32 %i.01, 5, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_5 = (loop_1_i_stage0 + 32'd5);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep13 = getelementptr [100 x i32]* @c, i32 0, i32 %5, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep13 = (`TAG_g_c_a + (4 * main_1_5));
end
always @(*) begin
	/* main: %1*/
	/*   %6 = add i32 %i.01, 4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_6 = (loop_1_i_stage0 + 32'd4);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep14 = getelementptr [100 x i32]* @c, i32 0, i32 %6, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep14 = (`TAG_g_c_a + (4 * main_1_6));
end
always @(*) begin
	/* main: %1*/
	/*   %7 = add i32 %i.01, 3, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_7 = (loop_1_i_stage0 + 32'd3);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep15 = getelementptr [100 x i32]* @j, i32 0, i32 %7, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep15 = (`TAG_g_j_a + (4 * main_1_7));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep16 = getelementptr [100 x i32]* @h, i32 0, i32 %7, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep16 = (`TAG_g_h_a + (4 * main_1_7));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep17 = getelementptr [100 x i32]* @f, i32 0, i32 %7, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep17 = (`TAG_g_f_a + (4 * main_1_7));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep18 = getelementptr [100 x i32]* @b, i32 0, i32 %7, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep18 = (`TAG_g_b_a + (4 * main_1_7));
end
always @(*) begin
	/* main: %1*/
	/*   %8 = add i32 %i.01, 2, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_8 = (loop_1_i_stage0 + 32'd2);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep19 = getelementptr [100 x i32]* @j, i32 0, i32 %8, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep19 = (`TAG_g_j_a + (4 * main_1_8));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep20 = getelementptr [100 x i32]* @h, i32 0, i32 %8, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep20 = (`TAG_g_h_a + (4 * main_1_8));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep21 = getelementptr [100 x i32]* @f, i32 0, i32 %8, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep21 = (`TAG_g_f_a + (4 * main_1_8));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep22 = getelementptr [100 x i32]* @b, i32 0, i32 %8, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep22 = (`TAG_g_b_a + (4 * main_1_8));
end
always @(*) begin
	/* main: %1*/
	/*   %9 = add i32 %i.01, 8, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_9 = (loop_1_i_stage0 + 32'd8);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep23 = getelementptr [100 x i32]* @dd, i32 0, i32 %9, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep23 = (`TAG_g_dd_a + (4 * main_1_9));
end
always @(*) begin
	/* main: %1*/
	/*   %10 = add i32 %i.01, 9, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_10 = (loop_1_i_stage0 + 32'd9);
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep24 = getelementptr [100 x i32]* @dd, i32 0, i32 %10, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
	start_time: 0 avail_time: 0 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 0 % 12 = 0*/
		main_1_scevgep24 = (`TAG_g_dd_a + (4 * main_1_10));
end
always @(*) begin
	/* main: %1*/
	/*   %11 = load volatile i32* %scevgep24, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
		main_1_11 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %12 = load volatile i32* %scevgep23, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
		main_1_12 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %13 = load volatile i32* %scevgep22, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
		main_1_13 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %14 = load volatile i32* %scevgep18, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
		main_1_14 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %15 = load volatile i32* %scevgep14, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
		main_1_15 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %16 = load volatile i32* %scevgep13, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
		main_1_16 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %17 = load volatile i32* %scevgep12, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
		main_1_17 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %18 = load volatile i32* %scevgep11, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
		main_1_18 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %19 = load volatile i32* %scevgep10, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
		main_1_19 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %21 = load volatile i32* %scevgep9, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
		main_1_21 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %22 = load volatile i32* %scevgep21, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
		main_1_22 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %23 = load volatile i32* %scevgep17, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
		main_1_23 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %24 = load volatile i32* %scevgep6, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
		main_1_24 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %25 = load volatile i32* %scevgep8, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
		main_1_25 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %26 = load volatile i32* %scevgep20, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
		main_1_26 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %27 = load volatile i32* %scevgep16, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
		main_1_27 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %28 = load volatile i32* %scevgep5, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
		main_1_28 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %29 = load volatile i32* %scevgep19, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
		main_1_29 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %30 = load volatile i32* %scevgep15, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
		main_1_30 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %31 = add i32 %12, %11, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 2 avail_time: 2 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 2 % 12 = 2*/
		main_1_31 = (main_1_12 + main_1_11);
end
always @(*) begin
	/* main: %1*/
	/*   %32 = add i32 %31, %13, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 3 avail_time: 3 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 3 % 12 = 3*/
		main_1_32 = (main_1_31_reg_stage0 + main_1_13);
end
always @(*) begin
	/* main: %1*/
	/*   %33 = add i32 %32, %14, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 4 avail_time: 4 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 4 % 12 = 4*/
		main_1_33 = (main_1_32_reg_stage0 + main_1_14);
end
always @(*) begin
	/* main: %1*/
	/*   %34 = add i32 %33, %15, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 4 avail_time: 4 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 4 % 12 = 4*/
		main_1_34 = (main_1_33 + main_1_15_reg_stage0);
end
always @(*) begin
	/* main: %1*/
	/*   %35 = add i32 %34, %16, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 4 avail_time: 4 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 4 % 12 = 4*/
		main_1_35 = (main_1_34 + main_1_16);
end
always @(*) begin
	/* main: %1*/
	/*   %36 = add i32 %35, %17, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 5 avail_time: 5 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 5 % 12 = 5*/
		main_1_36 = (main_1_35_reg_stage0 + main_1_17);
end
always @(*) begin
	/* main: %1*/
	/*   %37 = add i32 %36, %18, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 5 avail_time: 5 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 5 % 12 = 5*/
		main_1_37 = (main_1_36 + main_1_18);
end
always @(*) begin
	/* main: %1*/
	/*   %38 = add i32 %37, %19, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 6 avail_time: 6 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 6 % 12 = 6*/
		main_1_38 = (main_1_37_reg_stage0 + main_1_19);
end
always @(*) begin
	/* main: %1*/
	/*   %39 = add i32 %38, %21, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 7 avail_time: 7 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 7 % 12 = 7*/
		main_1_39 = (main_1_38_reg_stage0 + main_1_21);
end
always @(*) begin
	/* main: %1*/
	/*   %40 = add i32 %39, %22, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 7 avail_time: 7 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 7 % 12 = 7*/
		main_1_40 = (main_1_39 + main_1_22_reg_stage0);
end
always @(*) begin
	/* main: %1*/
	/*   %41 = add i32 %40, %23, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 7 avail_time: 7 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 7 % 12 = 7*/
		main_1_41 = (main_1_40 + main_1_23);
end
always @(*) begin
	/* main: %1*/
	/*   %42 = add i32 %41, %24, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 8 avail_time: 8 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 8 % 12 = 8*/
		main_1_42 = (main_1_41_reg_stage0 + main_1_24);
end
always @(*) begin
	/* main: %1*/
	/*   %43 = add i32 %42, %25, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 8 avail_time: 8 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 8 % 12 = 8*/
		main_1_43 = (main_1_42 + main_1_25);
end
always @(*) begin
	/* main: %1*/
	/*   %44 = add i32 %43, %26, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 9 avail_time: 9 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 9 % 12 = 9*/
		main_1_44 = (main_1_43_reg_stage0 + main_1_26);
end
always @(*) begin
	/* main: %1*/
	/*   %45 = add i32 %44, %27, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 9 avail_time: 9 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 9 % 12 = 9*/
		main_1_45 = (main_1_44 + main_1_27);
end
always @(*) begin
	/* main: %1*/
	/*   %46 = add i32 %45, %28, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 10 avail_time: 10 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 10 % 12 = 10*/
		main_1_46 = (main_1_45_reg_stage0 + main_1_28);
end
always @(*) begin
	/* main: %1*/
	/*   %47 = add i32 %46, %29, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 10 avail_time: 10 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 10 % 12 = 10*/
		main_1_47 = (main_1_46 + main_1_29);
end
always @(*) begin
	/* main: %1*/
	/*   %48 = add i32 %47, %30, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 11 avail_time: 11 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 11 % 12 = 11*/
		main_1_48 = (main_1_47_reg_stage0 + main_1_30);
end
always @(*) begin
	/* main: %1*/
	/*   %49 = load volatile i32* %scevgep, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
		main_1_49 = memory_controller_out_b[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %50 = add i32 %12, %11, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 2 avail_time: 2 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 2 % 12 = 2*/
		main_1_50 = (main_1_12 + main_1_11);
end
always @(*) begin
	/* main: %1*/
	/*   %51 = add i32 %50, %13, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 3 avail_time: 3 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 3 % 12 = 3*/
		main_1_51 = (main_1_50_reg_stage0 + main_1_13);
end
always @(*) begin
	/* main: %1*/
	/*   %52 = add i32 %51, %14, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 4 avail_time: 4 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 4 % 12 = 4*/
		main_1_52 = (main_1_51_reg_stage0 + main_1_14);
end
always @(*) begin
	/* main: %1*/
	/*   %53 = add i32 %52, %15, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 4 avail_time: 4 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 4 % 12 = 4*/
		main_1_53 = (main_1_52 + main_1_15_reg_stage0);
end
always @(*) begin
	/* main: %1*/
	/*   %54 = add i32 %53, %16, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 4 avail_time: 4 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 4 % 12 = 4*/
		main_1_54 = (main_1_53 + main_1_16);
end
always @(*) begin
	/* main: %1*/
	/*   %55 = add i32 %54, %17, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 5 avail_time: 5 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 5 % 12 = 5*/
		main_1_55 = (main_1_54_reg_stage0 + main_1_17);
end
always @(*) begin
	/* main: %1*/
	/*   %56 = add i32 %55, %18, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 5 avail_time: 5 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 5 % 12 = 5*/
		main_1_56 = (main_1_55 + main_1_18);
end
always @(*) begin
	/* main: %1*/
	/*   %57 = add i32 %56, %19, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 6 avail_time: 6 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 6 % 12 = 6*/
		main_1_57 = (main_1_56_reg_stage0 + main_1_19);
end
always @(*) begin
	/* main: %1*/
	/*   %58 = add i32 %57, %21, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 7 avail_time: 7 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 7 % 12 = 7*/
		main_1_58 = (main_1_57_reg_stage0 + main_1_21);
end
always @(*) begin
	/* main: %1*/
	/*   %59 = add i32 %58, %22, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 7 avail_time: 7 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 7 % 12 = 7*/
		main_1_59 = (main_1_58 + main_1_22_reg_stage0);
end
always @(*) begin
	/* main: %1*/
	/*   %60 = add i32 %59, %23, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 7 avail_time: 7 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 7 % 12 = 7*/
		main_1_60 = (main_1_59 + main_1_23);
end
always @(*) begin
	/* main: %1*/
	/*   %61 = add i32 %60, %24, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 8 avail_time: 8 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 8 % 12 = 8*/
		main_1_61 = (main_1_60_reg_stage0 + main_1_24);
end
always @(*) begin
	/* main: %1*/
	/*   %62 = add i32 %61, %25, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 8 avail_time: 8 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 8 % 12 = 8*/
		main_1_62 = (main_1_61 + main_1_25);
end
always @(*) begin
	/* main: %1*/
	/*   %63 = add i32 %62, %26, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 9 avail_time: 9 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 9 % 12 = 9*/
		main_1_63 = (main_1_62_reg_stage0 + main_1_26);
end
always @(*) begin
	/* main: %1*/
	/*   %64 = add i32 %63, %27, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 9 avail_time: 9 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 9 % 12 = 9*/
		main_1_64 = (main_1_63 + main_1_27);
end
always @(*) begin
	/* main: %1*/
	/*   %65 = add i32 %64, %28, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 10 avail_time: 10 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 10 % 12 = 10*/
		main_1_65 = (main_1_64_reg_stage0 + main_1_28);
end
always @(*) begin
	/* main: %1*/
	/*   %66 = add i32 %65, %29, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 10 avail_time: 10 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 10 % 12 = 10*/
		main_1_66 = (main_1_65 + main_1_29);
end
always @(*) begin
	/* main: %1*/
	/*   %67 = add i32 %66, %30, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 11 avail_time: 11 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 11 % 12 = 11*/
		main_1_67 = (main_1_66_reg_stage0 + main_1_30);
end
always @(*) begin
	/* main: %1*/
	/*   %68 = add i32 %67, %49, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 11 avail_time: 11 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 11 % 12 = 11*/
		main_1_68 = (main_1_67 + main_1_49);
end
always @(*) begin
	/* main: %1*/
	/*   %69 = add i32 %68, %i.01, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 11 avail_time: 11 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 11 % 12 = 11*/
		main_1_69 = (main_1_68 + loop_1_i_stage0);
end
always @(*) begin
	/* main: %70*/
	/*   %71 = load volatile i32* getelementptr inbounds ([100 x i32]* @dd, i32 0, i32 90), align 4, !tbaa !4*/
		main_70_71 = memory_controller_out_a[31:0];
end
always @(posedge clk) begin
	/* main: %70*/
	/*   %71 = load volatile i32* getelementptr inbounds ([100 x i32]* @dd, i32 0, i32 90), align 4, !tbaa !4*/
	if ((cur_state == LEGUP_F_main_BB__70_4)) begin
		main_70_71_reg <= main_70_71;
		if (start == 1'b0 && ^(main_70_71) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_70_71_reg"); $finish; end
	end
end
always @(*) begin
	/* main: %70*/
	/*   %73 = icmp eq i32 %71, 87301*/
		main_70_73 = (main_70_71 == 32'd87301);
end
always @(*) begin
	loop_1_pipeline_start = 1'd0;
	if (reset) begin
		loop_1_pipeline_start = 1'd0;
	end
	if ((((cur_state == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		loop_1_pipeline_start = 1'd1;
	end
end
always @(posedge clk) begin
	if (reset) begin
		loop_1_started <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_started"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_pipeline_start & ~(loop_1_started)))) begin
		loop_1_started <= 1'd1;
		if (start == 1'b0 && ^(1'd1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_started"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_epilogue & (~(loop_1_valid_bit_11) & loop_1_valid_bit_12)))) begin
		loop_1_started <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_started"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset) begin
		loop_1_ii_state <= 4'd0;
		if (start == 1'b0 && ^(4'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_pipeline_start & ~(loop_1_started)))) begin
		loop_1_ii_state <= 4'd0;
		if (start == 1'b0 && ^(4'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd0))) begin
		loop_1_ii_state <= 4'd1;
		if (start == 1'b0 && ^(4'd1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd1))) begin
		loop_1_ii_state <= 4'd2;
		if (start == 1'b0 && ^(4'd2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd2))) begin
		loop_1_ii_state <= 4'd3;
		if (start == 1'b0 && ^(4'd3) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd3))) begin
		loop_1_ii_state <= 4'd4;
		if (start == 1'b0 && ^(4'd4) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd4))) begin
		loop_1_ii_state <= 4'd5;
		if (start == 1'b0 && ^(4'd5) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd5))) begin
		loop_1_ii_state <= 4'd6;
		if (start == 1'b0 && ^(4'd6) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd6))) begin
		loop_1_ii_state <= 4'd7;
		if (start == 1'b0 && ^(4'd7) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd7))) begin
		loop_1_ii_state <= 4'd8;
		if (start == 1'b0 && ^(4'd8) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd8))) begin
		loop_1_ii_state <= 4'd9;
		if (start == 1'b0 && ^(4'd9) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd9))) begin
		loop_1_ii_state <= 4'd10;
		if (start == 1'b0 && ^(4'd10) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd10))) begin
		loop_1_ii_state <= 4'd11;
		if (start == 1'b0 && ^(4'd11) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd11))) begin
		loop_1_ii_state <= 4'd0;
		if (start == 1'b0 && ^(4'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_ii_state"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset) begin
		loop_1_i_stage0 <= 0;
		if (start == 1'b0 && ^(0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_i_stage0"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_pipeline_start & ~(loop_1_started)))) begin
		loop_1_i_stage0 <= 0;
		if (start == 1'b0 && ^(0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_i_stage0"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (((memory_controller_waitrequest == 1'd0) & (loop_1_ii_state == 4'd11)) & loop_1_valid_bit_11))) begin
		loop_1_i_stage0 <= (loop_1_i_stage0 + 1'd1);
		if (start == 1'b0 && ^((loop_1_i_stage0 + 1'd1)) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_i_stage0"); $finish; end
	end
	if (reset) begin
		loop_1_i_stage0 <= 0;
		if (start == 1'b0 && ^(0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_i_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset) begin
		loop_1_epilogue <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_epilogue"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_started & ((loop_1_ii_state == 4'd0) & loop_1_pipeline_exit_cond)))) begin
		loop_1_epilogue <= 1'd1;
		if (start == 1'b0 && ^(1'd1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_epilogue"); $finish; end
	end
	if (((memory_controller_waitrequest == 1'd0) & (loop_1_epilogue & (~(loop_1_valid_bit_11) & loop_1_valid_bit_12)))) begin
		loop_1_epilogue <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_epilogue"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_0 <= (((memory_controller_waitrequest == 1'd0) & (loop_1_pipeline_start & ~(loop_1_started))) | ((loop_1_started & ~(loop_1_epilogue)) & ~(((memory_controller_waitrequest == 1'd0) & (loop_1_started & ((loop_1_ii_state == 4'd0) & loop_1_pipeline_exit_cond))))));
		if (start == 1'b0 && ^((((memory_controller_waitrequest == 1'd0) & (loop_1_pipeline_start & ~(loop_1_started))) | ((loop_1_started & ~(loop_1_epilogue)) & ~(((memory_controller_waitrequest == 1'd0) & (loop_1_started & ((loop_1_ii_state == 4'd0) & loop_1_pipeline_exit_cond))))))) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_0"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_0 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_0"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_1 <= loop_1_valid_bit_0;
		if (start == 1'b0 && ^(loop_1_valid_bit_0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_1"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_1 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_1"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_2 <= loop_1_valid_bit_1;
		if (start == 1'b0 && ^(loop_1_valid_bit_1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_2"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_2 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_2"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_3 <= loop_1_valid_bit_2;
		if (start == 1'b0 && ^(loop_1_valid_bit_2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_3"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_3 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_3"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_4 <= loop_1_valid_bit_3;
		if (start == 1'b0 && ^(loop_1_valid_bit_3) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_4"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_4 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_4"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_5 <= loop_1_valid_bit_4;
		if (start == 1'b0 && ^(loop_1_valid_bit_4) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_5"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_5 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_5"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_6 <= loop_1_valid_bit_5;
		if (start == 1'b0 && ^(loop_1_valid_bit_5) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_6"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_6 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_6"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_7 <= loop_1_valid_bit_6;
		if (start == 1'b0 && ^(loop_1_valid_bit_6) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_7"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_7 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_7"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_8 <= loop_1_valid_bit_7;
		if (start == 1'b0 && ^(loop_1_valid_bit_7) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_8"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_8 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_8"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_9 <= loop_1_valid_bit_8;
		if (start == 1'b0 && ^(loop_1_valid_bit_8) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_9"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_9 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_9"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_10 <= loop_1_valid_bit_9;
		if (start == 1'b0 && ^(loop_1_valid_bit_9) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_10"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_10 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_10"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_11 <= loop_1_valid_bit_10;
		if (start == 1'b0 && ^(loop_1_valid_bit_10) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_11"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_11 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_11"); $finish; end
	end
end
always @(posedge clk) begin
	if ((memory_controller_waitrequest == 1'd0)) begin
		loop_1_valid_bit_12 <= loop_1_valid_bit_11;
		if (start == 1'b0 && ^(loop_1_valid_bit_11) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_12"); $finish; end
	end
	if (reset) begin
		loop_1_valid_bit_12 <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to loop_1_valid_bit_12"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep_reg_stage0 <= main_1_scevgep;
		if (start == 1'b0 && ^(main_1_scevgep) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep2_reg_stage0 <= main_1_scevgep2;
		if (start == 1'b0 && ^(main_1_scevgep2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep2_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep3_reg_stage0 <= main_1_scevgep3;
		if (start == 1'b0 && ^(main_1_scevgep3) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep3_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep4_reg_stage0 <= main_1_scevgep4;
		if (start == 1'b0 && ^(main_1_scevgep4) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep4_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep5_reg_stage0 <= main_1_scevgep5;
		if (start == 1'b0 && ^(main_1_scevgep5) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep5_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep6_reg_stage0 <= main_1_scevgep6;
		if (start == 1'b0 && ^(main_1_scevgep6) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep6_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep7_reg_stage0 <= main_1_scevgep7;
		if (start == 1'b0 && ^(main_1_scevgep7) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep7_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep8_reg_stage0 <= main_1_scevgep8;
		if (start == 1'b0 && ^(main_1_scevgep8) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep8_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep9_reg_stage0 <= main_1_scevgep9;
		if (start == 1'b0 && ^(main_1_scevgep9) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep9_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep10_reg_stage0 <= main_1_scevgep10;
		if (start == 1'b0 && ^(main_1_scevgep10) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep10_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep11_reg_stage0 <= main_1_scevgep11;
		if (start == 1'b0 && ^(main_1_scevgep11) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep11_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep12_reg_stage0 <= main_1_scevgep12;
		if (start == 1'b0 && ^(main_1_scevgep12) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep12_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep13_reg_stage0 <= main_1_scevgep13;
		if (start == 1'b0 && ^(main_1_scevgep13) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep13_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep14_reg_stage0 <= main_1_scevgep14;
		if (start == 1'b0 && ^(main_1_scevgep14) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep14_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep15_reg_stage0 <= main_1_scevgep15;
		if (start == 1'b0 && ^(main_1_scevgep15) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep15_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep16_reg_stage0 <= main_1_scevgep16;
		if (start == 1'b0 && ^(main_1_scevgep16) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep16_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep17_reg_stage0 <= main_1_scevgep17;
		if (start == 1'b0 && ^(main_1_scevgep17) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep17_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep18_reg_stage0 <= main_1_scevgep18;
		if (start == 1'b0 && ^(main_1_scevgep18) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep18_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep19_reg_stage0 <= main_1_scevgep19;
		if (start == 1'b0 && ^(main_1_scevgep19) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep19_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep20_reg_stage0 <= main_1_scevgep20;
		if (start == 1'b0 && ^(main_1_scevgep20) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep20_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep21_reg_stage0 <= main_1_scevgep21;
		if (start == 1'b0 && ^(main_1_scevgep21) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep21_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0))) begin
		main_1_scevgep22_reg_stage0 <= main_1_scevgep22;
		if (start == 1'b0 && ^(main_1_scevgep22) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_scevgep22_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3))) begin
		main_1_15_reg_stage0 <= main_1_15;
		if (start == 1'b0 && ^(main_1_15) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_15_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6))) begin
		main_1_22_reg_stage0 <= main_1_22;
		if (start == 1'b0 && ^(main_1_22) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_22_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2))) begin
		main_1_31_reg_stage0 <= main_1_31;
		if (start == 1'b0 && ^(main_1_31) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_31_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3))) begin
		main_1_32_reg_stage0 <= main_1_32;
		if (start == 1'b0 && ^(main_1_32) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_32_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4))) begin
		main_1_35_reg_stage0 <= main_1_35;
		if (start == 1'b0 && ^(main_1_35) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_35_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5))) begin
		main_1_37_reg_stage0 <= main_1_37;
		if (start == 1'b0 && ^(main_1_37) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_37_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6))) begin
		main_1_38_reg_stage0 <= main_1_38;
		if (start == 1'b0 && ^(main_1_38) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_38_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7))) begin
		main_1_41_reg_stage0 <= main_1_41;
		if (start == 1'b0 && ^(main_1_41) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_41_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8))) begin
		main_1_43_reg_stage0 <= main_1_43;
		if (start == 1'b0 && ^(main_1_43) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_43_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9))) begin
		main_1_45_reg_stage0 <= main_1_45;
		if (start == 1'b0 && ^(main_1_45) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_45_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10))) begin
		main_1_47_reg_stage0 <= main_1_47;
		if (start == 1'b0 && ^(main_1_47) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_47_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2))) begin
		main_1_50_reg_stage0 <= main_1_50;
		if (start == 1'b0 && ^(main_1_50) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_50_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3))) begin
		main_1_51_reg_stage0 <= main_1_51;
		if (start == 1'b0 && ^(main_1_51) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_51_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4))) begin
		main_1_54_reg_stage0 <= main_1_54;
		if (start == 1'b0 && ^(main_1_54) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_54_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5))) begin
		main_1_56_reg_stage0 <= main_1_56;
		if (start == 1'b0 && ^(main_1_56) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_56_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6))) begin
		main_1_57_reg_stage0 <= main_1_57;
		if (start == 1'b0 && ^(main_1_57) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_57_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7))) begin
		main_1_60_reg_stage0 <= main_1_60;
		if (start == 1'b0 && ^(main_1_60) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_60_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8))) begin
		main_1_62_reg_stage0 <= main_1_62;
		if (start == 1'b0 && ^(main_1_62) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_62_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9))) begin
		main_1_64_reg_stage0 <= main_1_64;
		if (start == 1'b0 && ^(main_1_64) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_64_reg_stage0"); $finish; end
	end
end
always @(posedge clk) begin
	if (((memory_controller_waitrequest == 1'd0) & ((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10))) begin
		main_1_66_reg_stage0 <= main_1_66;
		if (start == 1'b0 && ^(main_1_66) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_66_reg_stage0"); $finish; end
	end
end
always @(*) begin
	loop_1_pipeline_exit_cond = (loop_1_i_stage0 == 89);
end
always @(*) begin
	loop_1_pipeline_finish = ((memory_controller_waitrequest == 1'd0) & (loop_1_epilogue & (~(loop_1_valid_bit_11) & loop_1_valid_bit_12)));
end
always @(posedge clk) begin
	if ((cur_state == LEGUP_0)) begin
		finish <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to finish"); $finish; end
	end
	/* main: %78*/
	/*   ret i32 %71*/
	if ((cur_state == LEGUP_F_main_BB__78_7)) begin
		finish <= (memory_controller_waitrequest == 1'd0);
		if (start == 1'b0 && ^((memory_controller_waitrequest == 1'd0)) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to finish"); $finish; end
	end
end
always @(*) begin
	memory_controller_enable_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %11 = load volatile i32* %scevgep24, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %13 = load volatile i32* %scevgep22, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %14 = load volatile i32* %scevgep18, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %17 = load volatile i32* %scevgep12, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %19 = load volatile i32* %scevgep10, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %21 = load volatile i32* %scevgep9, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %24 = load volatile i32* %scevgep6, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %26 = load volatile i32* %scevgep20, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %28 = load volatile i32* %scevgep5, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   %30 = load volatile i32* %scevgep15, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   store volatile i32 %37, i32* %scevgep4, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   store volatile i32 %48, i32* %scevgep2, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_enable_a = 1'd1;
	end
	/* main: %70*/
	/*   %71 = load volatile i32* getelementptr inbounds ([100 x i32]* @dd, i32 0, i32 90), align 4, !tbaa !4*/
	if ((cur_state == LEGUP_F_main_BB__70_2)) begin
		memory_controller_enable_a = 1'd1;
	end
end
always @(*) begin
	memory_controller_address_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_address_a = 1'd0;
	end
	/* main: %1*/
	/*   %11 = load volatile i32* %scevgep24, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_address_a = main_1_scevgep24;
	end
	/* main: %1*/
	/*   %13 = load volatile i32* %scevgep22, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_address_a = main_1_scevgep22_reg_stage0;
	end
	/* main: %1*/
	/*   %14 = load volatile i32* %scevgep18, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_address_a = main_1_scevgep18_reg_stage0;
	end
	/* main: %1*/
	/*   %17 = load volatile i32* %scevgep12, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_address_a = main_1_scevgep12_reg_stage0;
	end
	/* main: %1*/
	/*   %19 = load volatile i32* %scevgep10, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_address_a = main_1_scevgep10_reg_stage0;
	end
	/* main: %1*/
	/*   %21 = load volatile i32* %scevgep9, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_address_a = main_1_scevgep9_reg_stage0;
	end
	/* main: %1*/
	/*   %24 = load volatile i32* %scevgep6, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_address_a = main_1_scevgep6_reg_stage0;
	end
	/* main: %1*/
	/*   %26 = load volatile i32* %scevgep20, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_address_a = main_1_scevgep20_reg_stage0;
	end
	/* main: %1*/
	/*   %28 = load volatile i32* %scevgep5, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_address_a = main_1_scevgep5_reg_stage0;
	end
	/* main: %1*/
	/*   %30 = load volatile i32* %scevgep15, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_address_a = main_1_scevgep15_reg_stage0;
	end
	/* main: %1*/
	/*   store volatile i32 %37, i32* %scevgep4, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_address_a = main_1_scevgep4_reg_stage0;
	end
	/* main: %1*/
	/*   store volatile i32 %48, i32* %scevgep2, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_address_a = main_1_scevgep2_reg_stage0;
	end
	/* main: %70*/
	/*   %71 = load volatile i32* getelementptr inbounds ([100 x i32]* @dd, i32 0, i32 90), align 4, !tbaa !4*/
	if ((cur_state == LEGUP_F_main_BB__70_2)) begin
		memory_controller_address_a = (`TAG_g_dd_a + (4 * 32'd90));
	end
end
always @(*) begin
	memory_controller_write_enable_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %11 = load volatile i32* %scevgep24, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %13 = load volatile i32* %scevgep22, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %14 = load volatile i32* %scevgep18, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %17 = load volatile i32* %scevgep12, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %19 = load volatile i32* %scevgep10, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %21 = load volatile i32* %scevgep9, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %24 = load volatile i32* %scevgep6, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %26 = load volatile i32* %scevgep20, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %28 = load volatile i32* %scevgep5, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %30 = load volatile i32* %scevgep15, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   store volatile i32 %37, i32* %scevgep4, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_write_enable_a = 1'd1;
	end
	/* main: %1*/
	/*   store volatile i32 %48, i32* %scevgep2, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_write_enable_a = 1'd1;
	end
	/* main: %70*/
	/*   %71 = load volatile i32* getelementptr inbounds ([100 x i32]* @dd, i32 0, i32 90), align 4, !tbaa !4*/
	if ((cur_state == LEGUP_F_main_BB__70_2)) begin
		memory_controller_write_enable_a = 1'd0;
	end
end
always @(*) begin
	memory_controller_in_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_in_a = 1'd0;
	end
	/* main: %1*/
	/*   store volatile i32 %37, i32* %scevgep4, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_in_a = main_1_37_reg_stage0;
	end
	/* main: %1*/
	/*   store volatile i32 %48, i32* %scevgep2, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_in_a = main_1_48;
	end
end
always @(*) begin
	memory_controller_size_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_size_a = 1'd0;
	end
	/* main: %1*/
	/*   %11 = load volatile i32* %scevgep24, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %13 = load volatile i32* %scevgep22, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %14 = load volatile i32* %scevgep18, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %17 = load volatile i32* %scevgep12, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %19 = load volatile i32* %scevgep10, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %21 = load volatile i32* %scevgep9, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %24 = load volatile i32* %scevgep6, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %26 = load volatile i32* %scevgep20, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %28 = load volatile i32* %scevgep5, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   %30 = load volatile i32* %scevgep15, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   store volatile i32 %37, i32* %scevgep4, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %1*/
	/*   store volatile i32 %48, i32* %scevgep2, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_size_a = 2'd2;
	end
	/* main: %70*/
	/*   %71 = load volatile i32* getelementptr inbounds ([100 x i32]* @dd, i32 0, i32 90), align 4, !tbaa !4*/
	if ((cur_state == LEGUP_F_main_BB__70_2)) begin
		memory_controller_size_a = 2'd2;
	end
end
always @(*) begin
	memory_controller_enable_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %12 = load volatile i32* %scevgep23, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %15 = load volatile i32* %scevgep14, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %16 = load volatile i32* %scevgep13, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %18 = load volatile i32* %scevgep11, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %22 = load volatile i32* %scevgep21, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %23 = load volatile i32* %scevgep17, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %25 = load volatile i32* %scevgep8, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %27 = load volatile i32* %scevgep16, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %29 = load volatile i32* %scevgep19, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   store volatile i32 %45, i32* %scevgep3, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %49 = load volatile i32* %scevgep, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   store volatile i32 %69, i32* %scevgep7, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_enable_b = 1'd1;
	end
end
always @(*) begin
	memory_controller_address_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_address_b = 1'd0;
	end
	/* main: %1*/
	/*   %12 = load volatile i32* %scevgep23, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_address_b = main_1_scevgep23;
	end
	/* main: %1*/
	/*   %15 = load volatile i32* %scevgep14, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_address_b = main_1_scevgep14_reg_stage0;
	end
	/* main: %1*/
	/*   %16 = load volatile i32* %scevgep13, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_address_b = main_1_scevgep13_reg_stage0;
	end
	/* main: %1*/
	/*   %18 = load volatile i32* %scevgep11, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_address_b = main_1_scevgep11_reg_stage0;
	end
	/* main: %1*/
	/*   %22 = load volatile i32* %scevgep21, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_address_b = main_1_scevgep21_reg_stage0;
	end
	/* main: %1*/
	/*   %23 = load volatile i32* %scevgep17, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_address_b = main_1_scevgep17_reg_stage0;
	end
	/* main: %1*/
	/*   %25 = load volatile i32* %scevgep8, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_address_b = main_1_scevgep8_reg_stage0;
	end
	/* main: %1*/
	/*   %27 = load volatile i32* %scevgep16, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_address_b = main_1_scevgep16_reg_stage0;
	end
	/* main: %1*/
	/*   %29 = load volatile i32* %scevgep19, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_address_b = main_1_scevgep19_reg_stage0;
	end
	/* main: %1*/
	/*   store volatile i32 %45, i32* %scevgep3, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_address_b = main_1_scevgep3_reg_stage0;
	end
	/* main: %1*/
	/*   %49 = load volatile i32* %scevgep, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_address_b = main_1_scevgep_reg_stage0;
	end
	/* main: %1*/
	/*   store volatile i32 %69, i32* %scevgep7, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_address_b = main_1_scevgep7_reg_stage0;
	end
end
always @(*) begin
	memory_controller_write_enable_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %12 = load volatile i32* %scevgep23, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %15 = load volatile i32* %scevgep14, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %16 = load volatile i32* %scevgep13, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %18 = load volatile i32* %scevgep11, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %22 = load volatile i32* %scevgep21, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %23 = load volatile i32* %scevgep17, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %25 = load volatile i32* %scevgep8, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %27 = load volatile i32* %scevgep16, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   %29 = load volatile i32* %scevgep19, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   store volatile i32 %45, i32* %scevgep3, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_write_enable_b = 1'd1;
	end
	/* main: %1*/
	/*   %49 = load volatile i32* %scevgep, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_write_enable_b = 1'd0;
	end
	/* main: %1*/
	/*   store volatile i32 %69, i32* %scevgep7, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_write_enable_b = 1'd1;
	end
end
always @(*) begin
	memory_controller_in_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_in_b = 1'd0;
	end
	/* main: %1*/
	/*   store volatile i32 %45, i32* %scevgep3, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_in_b = main_1_45_reg_stage0;
	end
	/* main: %1*/
	/*   store volatile i32 %69, i32* %scevgep7, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_in_b = main_1_69;
	end
end
always @(*) begin
	memory_controller_size_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_size_b = 1'd0;
	end
	/* main: %1*/
	/*   %12 = load volatile i32* %scevgep23, align 4, !tbaa !4, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !8, !legup.pipeline.stage !3
	start_time: 0 avail_time: 2 stage: 0 II: 12 start_ii_state = 0 % 12 = 0 avail_ii_state = 2 % 12 = 2*/
	if (((loop_1_ii_state == 4'd0) & loop_1_valid_bit_0)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %15 = load volatile i32* %scevgep14, align 4, !tbaa !4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
	start_time: 1 avail_time: 3 stage: 0 II: 12 start_ii_state = 1 % 12 = 1 avail_ii_state = 3 % 12 = 3*/
	if (((loop_1_ii_state == 4'd1) & loop_1_valid_bit_1)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %16 = load volatile i32* %scevgep13, align 4, !tbaa !4, !legup.pipeline.start_time !8, !legup.pipeline.avail_time !10, !legup.pipeline.stage !3
	start_time: 2 avail_time: 4 stage: 0 II: 12 start_ii_state = 2 % 12 = 2 avail_ii_state = 4 % 12 = 4*/
	if (((loop_1_ii_state == 4'd2) & loop_1_valid_bit_2)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %18 = load volatile i32* %scevgep11, align 4, !tbaa !4, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !11, !legup.pipeline.stage !3
	start_time: 3 avail_time: 5 stage: 0 II: 12 start_ii_state = 3 % 12 = 3 avail_ii_state = 5 % 12 = 5*/
	if (((loop_1_ii_state == 4'd3) & loop_1_valid_bit_3)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %22 = load volatile i32* %scevgep21, align 4, !tbaa !4, !legup.pipeline.start_time !10, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
	start_time: 4 avail_time: 6 stage: 0 II: 12 start_ii_state = 4 % 12 = 4 avail_ii_state = 6 % 12 = 6*/
	if (((loop_1_ii_state == 4'd4) & loop_1_valid_bit_4)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %23 = load volatile i32* %scevgep17, align 4, !tbaa !4, !legup.pipeline.start_time !11, !legup.pipeline.avail_time !13, !legup.pipeline.stage !3
	start_time: 5 avail_time: 7 stage: 0 II: 12 start_ii_state = 5 % 12 = 5 avail_ii_state = 7 % 12 = 7*/
	if (((loop_1_ii_state == 4'd5) & loop_1_valid_bit_5)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %25 = load volatile i32* %scevgep8, align 4, !tbaa !4, !legup.pipeline.start_time !12, !legup.pipeline.avail_time !14, !legup.pipeline.stage !3
	start_time: 6 avail_time: 8 stage: 0 II: 12 start_ii_state = 6 % 12 = 6 avail_ii_state = 8 % 12 = 8*/
	if (((loop_1_ii_state == 4'd6) & loop_1_valid_bit_6)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %27 = load volatile i32* %scevgep16, align 4, !tbaa !4, !legup.pipeline.start_time !13, !legup.pipeline.avail_time !15, !legup.pipeline.stage !3
	start_time: 7 avail_time: 9 stage: 0 II: 12 start_ii_state = 7 % 12 = 7 avail_ii_state = 9 % 12 = 9*/
	if (((loop_1_ii_state == 4'd7) & loop_1_valid_bit_7)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %29 = load volatile i32* %scevgep19, align 4, !tbaa !4, !legup.pipeline.start_time !14, !legup.pipeline.avail_time !16, !legup.pipeline.stage !3
	start_time: 8 avail_time: 10 stage: 0 II: 12 start_ii_state = 8 % 12 = 8 avail_ii_state = 10 % 12 = 10*/
	if (((loop_1_ii_state == 4'd8) & loop_1_valid_bit_8)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   store volatile i32 %45, i32* %scevgep3, align 4, !tbaa !4, !legup.pipeline.start_time !16, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 10 avail_time: 11 stage: 0 II: 12 start_ii_state = 10 % 12 = 10 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd10) & loop_1_valid_bit_10)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   %49 = load volatile i32* %scevgep, align 4, !tbaa !4, !legup.pipeline.start_time !15, !legup.pipeline.avail_time !17, !legup.pipeline.stage !3
	start_time: 9 avail_time: 11 stage: 0 II: 12 start_ii_state = 9 % 12 = 9 avail_ii_state = 11 % 12 = 11*/
	if (((loop_1_ii_state == 4'd9) & loop_1_valid_bit_9)) begin
		memory_controller_size_b = 2'd2;
	end
	/* main: %1*/
	/*   store volatile i32 %69, i32* %scevgep7, align 4, !tbaa !4, !legup.pipeline.start_time !17, !legup.pipeline.avail_time !18, !legup.pipeline.stage !3
	start_time: 11 avail_time: 12 stage: 0 II: 12 start_ii_state = 11 % 12 = 11 avail_ii_state = 12 % 12 = 0*/
	if (((loop_1_ii_state == 4'd11) & loop_1_valid_bit_11)) begin
		memory_controller_size_b = 2'd2;
	end
end
always @(posedge clk) begin
	if ((cur_state == LEGUP_0)) begin
		return_val <= 0;
		if (start == 1'b0 && ^(0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to return_val"); $finish; end
	end
	/* main: %78*/
	/*   ret i32 %71*/
	if ((cur_state == LEGUP_F_main_BB__78_7)) begin
		return_val <= main_70_71_reg;
		if (start == 1'b0 && ^(main_70_71_reg) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to return_val"); $finish; end
	end
end

endmodule 
module ram_dual_port
(
	clk,
	clken,
	address_a,
	address_b,
	wren_a,
	wren_b,
	data_a,
	data_b,
	byteena_a,
	byteena_b,
	q_a,
	q_b
);

parameter  width_a = 1'd0;
parameter  width_b = 1'd0;
parameter  widthad_a = 1'd0;
parameter  widthad_b = 1'd0;
parameter  numwords_a = 1'd0;
parameter  numwords_b = 1'd0;
parameter  init_file = "UNUSED.mif";
parameter  width_be_a = 1'd0;
parameter  width_be_b = 1'd0;
parameter  latency = 1;

input  clk;
input  clken;
input [(widthad_a-1):0] address_a;
input [(widthad_b-1):0] address_b;
output wire [(width_a-1):0] q_a;
output wire [(width_b-1):0] q_b;
reg [(width_a-1):0] q_a_wire;
reg [(width_b-1):0] q_b_wire;
input  wren_a;
input  wren_b;
input [(width_a-1):0] data_a;
input [(width_b-1):0] data_b;
// byte enable is unsupported by inferred RAMs
input [width_be_a-1:0] byteena_a;
input [width_be_b-1:0] byteena_b;

(* ramstyle = "no_rw_check", ram_init_file = init_file *) reg [width_a-1:0] ram[numwords_a-1:0];

/* synthesis translate_off */
integer i;
ALTERA_MF_MEMORY_INITIALIZATION mem ();
reg [8*256:1] ram_ver_file;
initial begin
	if (init_file == "UNUSED.mif")
    begin
		for (i = 0; i < numwords_a; i = i + 1)
			ram[i] = 0;
    end
	else
    begin
        // modelsim can't read .mif files directly. So use Altera function to
        // convert them to .ver files
        mem.convert_to_ver_file(init_file, width_a, ram_ver_file);
        $readmemh(ram_ver_file, ram);
    end
end
/* synthesis translate_on */

always @ (posedge clk)
if (clken)
begin // Port A
if (wren_a)
begin
    ram[address_a] <= data_a;
    q_a_wire <= {width_a{1'bX}};
end
else
    q_a_wire <= ram[address_a];
end
always @ (posedge clk)
if (clken)
begin // Port b
if (wren_b)
begin
    ram[address_b] <= data_b;
    q_b_wire <= {width_b{1'bX}};
end
else
    q_b_wire <= ram[address_b];
end



integer j;
reg [(width_a-1):0] q_a_reg[latency:1], q_b_reg[latency:1];

always @(*)
begin
   q_a_reg[1] <= q_a_wire;
   q_b_reg[1] <= q_b_wire;
end

always @(posedge clk)
if (clken)
begin
   for (j = 1; j < latency; j=j+1)
   begin
       q_a_reg[j+1] <= q_a_reg[j];
       q_b_reg[j+1] <= q_b_reg[j];
   end
end

assign q_a = (clken) ? q_a_reg[latency] : 0;
assign q_b = (clken) ? q_b_reg[latency] : 0;


endmodule
module rom_dual_port
(
	clk,
	clken,
	address_a,
	address_b,
	q_a,
	q_b
);

parameter  width_a = 1'd0;
parameter  width_b = 1'd0;
parameter  widthad_a = 1'd0;
parameter  widthad_b = 1'd0;
parameter  numwords_a = 1'd0;
parameter  numwords_b = 1'd0;
parameter  init_file = "UNUSED.mif";
parameter  latency = 1;

input  clk;
input  clken;
input [(widthad_a-1):0] address_a;
input [(widthad_b-1):0] address_b;
output wire [(width_a-1):0] q_a;
output wire [(width_b-1):0] q_b;
reg [(width_a-1):0] q_a_wire;
reg [(width_b-1):0] q_b_wire;

(* ramstyle = "no_rw_check", ram_init_file = init_file *) reg [width_a-1:0] ram[numwords_a-1:0];

/* synthesis translate_off */
integer i;
ALTERA_MF_MEMORY_INITIALIZATION mem ();
reg [8*256:1] ram_ver_file;
initial begin
	if (init_file == "UNUSED.mif")
    begin
		for (i = 0; i < numwords_a; i = i + 1)
			ram[i] = 0;
    end
	else
    begin
        // modelsim can't read .mif files directly. So use Altera function to
        // convert them to .ver files
        mem.convert_to_ver_file(init_file, width_a, ram_ver_file);
        $readmemh(ram_ver_file, ram);
    end
end
/* synthesis translate_on */

always @ (posedge clk)
if (clken)
begin
    q_a_wire <= ram[address_a];
    q_b_wire <= ram[address_b];
end



integer j;
reg [(width_a-1):0] q_a_reg[latency:1], q_b_reg[latency:1];

always @(*)
begin
   q_a_reg[1] <= q_a_wire;
   q_b_reg[1] <= q_b_wire;
end

always @(posedge clk)
if (clken)
begin
   for (j = 1; j < latency; j=j+1)
   begin
       q_a_reg[j+1] <= q_a_reg[j];
       q_b_reg[j+1] <= q_b_reg[j];
   end
end

assign q_a = (clken) ? q_a_reg[latency] : 0;
assign q_b = (clken) ? q_b_reg[latency] : 0;


endmodule
// Adding code from verilog file: /home/leandro/myLegUp/4.0/examples/../boards/CycloneII/DE2/top.v


module de2 (
	    CLOCK_50,
	    KEY,
	    SW,
	    HEX0,
	    HEX1,
	    HEX2,
	    HEX3,
	    HEX4,
	    HEX5,
	    HEX6,
	    HEX7,
	    LEDG,
		UART_RXD,
		UART_TXD

	    );

   input CLOCK_50;
   input [3:0] KEY;
   input [17:0] SW;
   output [6:0] HEX0, HEX1,  HEX2,  HEX3,  HEX4,  HEX5,  HEX6,  HEX7;
   reg [6:0] 	hex0, hex1, hex2, hex3, hex4, hex5, hex6, hex7;
   

   output [7:0] LEDG;
    input UART_RXD;
    output UART_TXD;    
	wire clk = CLOCK_50;
	wire go = ~KEY[1];



   wire 	reset = ~KEY[0];
   wire 	start;
   wire [31:0] 	return_val;
   reg  [31:0] 	return_val_reg;
   wire 	finish;
   wire [3:0]	state;

   hex_digits h7( .x(hex7), .hex_LEDs(HEX7));
   hex_digits h6( .x(hex6), .hex_LEDs(HEX6));
   hex_digits h5( .x(hex5), .hex_LEDs(HEX5));
   hex_digits h4( .x(hex4), .hex_LEDs(HEX4));
   hex_digits h3( .x(hex3), .hex_LEDs(HEX3));
   hex_digits h2( .x(hex2), .hex_LEDs(HEX2));
   hex_digits h1( .x(hex1), .hex_LEDs(HEX1));
   hex_digits h0( .x(hex0), .hex_LEDs(HEX0));
   
	always @ (*) begin
		hex7 <= return_val_reg[31:28];
		hex6 <= return_val_reg[27:24];
		hex5 <= return_val_reg[23:20];
		hex4 <= return_val_reg[19:16];
		hex3 <= return_val_reg[15:12];
		hex2 <= return_val_reg[11:8];
		hex1 <= return_val_reg[7:4];
		hex0 <= return_val_reg[3:0];
	end
assign UART_TXD = 1'b0;

    parameter s_WAIT = 3'b001, s_START = 3'b010, s_EXE = 3'b011,
                s_DONE = 3'b100;

    // state registers
    reg [3:0] y_Q, Y_D;

    assign LEDG[3:0] = y_Q;

    // next state
    always @(*)
    begin
        case (y_Q)
            s_WAIT: if (go) Y_D = s_START; else Y_D = y_Q;

            s_START: Y_D = s_EXE;

            s_EXE: if (!finish) Y_D = s_EXE; else Y_D = s_DONE;

            s_DONE: Y_D = s_DONE;

            default: Y_D = 3'bxxx;
        endcase
    end

    // current state
    always @(posedge clk)
    begin
        if (reset) // synchronous clear
            y_Q <= s_WAIT;
        else
            y_Q <= Y_D;
    end

    always @(posedge clk)
        if (y_Q == s_EXE && finish)
            return_val_reg <= return_val;
        else if (y_Q == s_DONE)
            return_val_reg <= return_val_reg;
        else
            return_val_reg <= 0;


    assign start = (y_Q == s_START);

   
   top top_inst (
      .clk (clk),
      .reset (reset),
      .finish (finish),
      .return_val (return_val),
        .start (start)

    );

endmodule

// Adding code from verilog file: /home/leandro/myLegUp/4.0/examples/../boards/StratixIV/DE4/top.v


module de4 ( 
    	     OSC_50_BANK2, 
             BUTTON, 
             LED, 
    	     SEG0_D, 
    	     SEG1_D 
	     ); 
   input OSC_50_BANK2; 
   input [1:0] BUTTON; 
   output [6:0] SEG0_D; 
   output [6:0] SEG1_D; 
   output [7:0] LED; 
   
   de2 de2_inst ( 
		  .CLOCK_50 (OSC_50_BANK2), 
		  .LEDG (LED), 
		  .KEY (BUTTON), 
		  .SW (), 
		  .HEX0 (SEG0_D), 
		  .HEX1 (SEG1_D), 
		  .HEX2 (), 
		  .HEX3 (), 
		  .HEX4 (), 
		  .HEX5 (), 
		  .HEX6 (), 
		  .HEX7 () 
		  ); 
   
endmodule
// Adding code from verilog file: /home/leandro/myLegUp/4.0/examples/../boards/Virtex6/ML605/top.v


module ML605 (
       USER_CLOCK,
	    KEY,
	    SW,	    
       LED,
       LEDG,
		UART_RXD,
		UART_TXD

	    );

   input USER_CLOCK;
   input [4:0] KEY;
   input [7:0] SW;
   output [7:0] LED;
   output [7:0] LEDG;
   wire CLOCK_50;

    input UART_RXD;
    output UART_TXD;    
	wire clk = CLOCK_50;
	wire go = ~KEY[1];



   wire 	reset = ~KEY[0];
   wire 	start;
   wire [31:0] 	return_val;
   reg  [31:0] 	return_val_reg;
   wire 	finish;
   wire [3:0]	state;
   
   reg [6:0]   hex0, hex1, hex2, hex3, hex4, hex5, hex6, hex7;

   assign CLOCK_50 = USER_CLOCK;
   assign LED = 0;
   
	always @ (*) begin
		hex7 <= return_val_reg[31:28];
		hex6 <= return_val_reg[27:24];
		hex5 <= return_val_reg[23:20];
		hex4 <= return_val_reg[19:16];
		hex3 <= return_val_reg[15:12];
		hex2 <= return_val_reg[11:8];
		hex1 <= return_val_reg[7:4];
		hex0 <= return_val_reg[3:0];
	end
assign UART_TXD = 1'b0;

    parameter s_WAIT = 3'b001, s_START = 3'b010, s_EXE = 3'b011,
                s_DONE = 3'b100;

    // state registers
    reg [3:0] y_Q, Y_D;

    assign LEDG[3:0] = y_Q;

    // next state
    always @(*)
    begin
        case (y_Q)
            s_WAIT: if (go) Y_D = s_START; else Y_D = y_Q;

            s_START: Y_D = s_EXE;

            s_EXE: if (!finish) Y_D = s_EXE; else Y_D = s_DONE;

            s_DONE: Y_D = s_DONE;

            default: Y_D = 3'bxxx;
        endcase
    end

    // current state
    always @(posedge clk)
    begin
        if (reset) // synchronous clear
            y_Q <= s_WAIT;
        else
            y_Q <= Y_D;
    end

    always @(posedge clk)
        if (y_Q == s_EXE && finish)
            return_val_reg <= return_val;
        else if (y_Q == s_DONE)
            return_val_reg <= return_val_reg;
        else
            return_val_reg <= 0;


    assign start = (y_Q == s_START);

   
   top top_inst (
      .clk (clk),
      .reset (reset),
      .finish (finish),
      .return_val (return_val),
        .start (start)

    );

   

endmodule

module circuit_start_control (
    go,
    control_key
);
    input control_key;
    output go;
    assign go = control_key;
endmodule
module hex_digits(x, hex_LEDs);
    input [3:0] x;
    output [6:0] hex_LEDs;
    
    assign hex_LEDs[0] = (~x[3] & ~x[2] & ~x[1] & x[0]) |
                            (~x[3] & x[2] & ~x[1] & ~x[0]) |
                            (x[3] & x[2] & ~x[1] & x[0]) |
                            (x[3] & ~x[2] & x[1] & x[0]);
    assign hex_LEDs[1] = (~x[3] & x[2] & ~x[1] & x[0]) |
                            (x[3] & x[1] & x[0]) |
                            (x[3] & x[2] & ~x[0]) |
                            (x[2] & x[1] & ~x[0]);
    assign hex_LEDs[2] = (x[3] & x[2] & ~x[0]) |
                            (x[3] & x[2] & x[1]) |
                            (~x[3] & ~x[2] & x[1] & ~x[0]);
    assign hex_LEDs[3] = (~x[3] & ~x[2] & ~x[1] & x[0]) | 
                            (~x[3] & x[2] & ~x[1] & ~x[0]) | 
                            (x[2] & x[1] & x[0]) | 
                            (x[3] & ~x[2] & x[1] & ~x[0]);
    assign hex_LEDs[4] = (~x[3] & x[0]) |
                            (~x[3] & x[2] & ~x[1]) |
                            (~x[2] & ~x[1] & x[0]);
    assign hex_LEDs[5] = (~x[3] & ~x[2] & x[0]) | 
                            (~x[3] & ~x[2] & x[1]) | 
                            (~x[3] & x[1] & x[0]) | 
                            (x[3] & x[2] & ~x[1] & x[0]);
    assign hex_LEDs[6] = (~x[3] & ~x[2] & ~x[1]) | 
                            (x[3] & x[2] & ~x[1] & ~x[0]) | 
                            (~x[3] & x[2] & x[1] & x[0]);
    
endmodule
`timescale 1 ns / 1 ns
module main_tb
(
);

reg  clk;
reg  reset;
reg  start;
reg  waitrequest;
wire [31:0] return_val;
wire  finish;


top top_inst (
	.clk (clk),
	.reset (reset),
	.start (start),
	.waitrequest (waitrequest),
	.finish (finish),
	.return_val (return_val)
);




initial 
    clk = 0;
always @(clk)
    clk <= #10 ~clk;

initial begin
//$monitor("At t=%t clk=%b %b %b %b %d", $time, clk, reset, start, finish, return_val);
@(negedge clk);
reset <= 1;
@(negedge clk);
reset <= 0;
start <= 1;
@(negedge clk);
start <= 0;
end

always@(finish) begin
    if (finish == 1) begin
        $display("At t=%t clk=%b finish=%b return_val=%d", $time, clk, finish, return_val);
        $display("Cycles: %d", ($time-50)/20);
        $finish;
    end
end

initial begin
waitrequest <= 1;
@(negedge clk);
@(negedge clk);
waitrequest <= 0;
end


endmodule 
