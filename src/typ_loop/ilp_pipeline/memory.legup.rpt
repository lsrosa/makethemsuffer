//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 4.0 (http://legup.org)
// Compiled: Tue Feb 14 19:47:56 2017
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Fri Apr 28 20:19:11 2017
//----------------------------------------------------------------------------//

allocateRAM: %A
Constant: 0
# of Vertices: 28
Representatives: 
1 -> 1
2 -> 2
3 -> 3
4 -> 4
5 -> 5
6 -> 6
7 -> 7
8 -> 8
9 -> 9
10 -> 10
11 -> 11
12 -> 12
13 -> 13
14 -> 14
15 -> 15
16 -> 16
17 -> 17
18 -> 18
19 -> 19
20 -> 20
21 -> 21
22 -> 22
23 -> 23
24 -> 24
25 -> 25
26 -> 26
27 -> 27
28 -> 28

Connections (Graph): 
1 -> 
2 -> 
3 -> 21 22 23 24 28 
4 -> 7 9 11 13 15 17 19 20 27 
5 -> 
6 -> 5 8 10 12 14 16 18 
7 -> 
8 -> 
9 -> 
10 -> 
11 -> 
12 -> 
13 -> 
14 -> 
15 -> 
16 -> 
17 -> 
18 -> 
19 -> 
20 -> 
21 -> 
22 -> 
23 -> 
24 -> 
25 -> 
26 -> 25 
27 -> 
28 -> 

Points-to-set: 
1 -> {}
2 -> {1, }
3 -> {}
4 -> {3, }
5 -> {}
6 -> {}
7 -> {3, }
8 -> {}
9 -> {3, }
10 -> {}
11 -> {3, }
12 -> {}
13 -> {3, }
14 -> {}
15 -> {3, }
16 -> {}
17 -> {3, }
18 -> {}
19 -> {3, }
20 -> {3, }
21 -> {}
22 -> {}
23 -> {}
24 -> {}
25 -> {}
26 -> {}
27 -> {3, }
28 -> {}

Variable: Int -> Value* mapping
2: @.str = private unnamed_addr constant [6 x i8] c"loop1\00", align 1
6:   %1 = mul i32 %indvar, 100, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
5:   %2 = add i32 %1, 104, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
7:   %scevgep = getelementptr [10000 x i32]* %A, i32 0, i32 %2, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
8:   %3 = add i32 %1, 6, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
21:   %10 = load i32* %scevgep8, align 4, !tbaa !5, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
4:   %A = alloca [10000 x i32], align 4
26:   %indvar = phi i32 [ %indvar.next, %.preheader ], [ 0, %0 ], !legup.canonical_induction !2, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
27:   %15 = getelementptr inbounds [10000 x i32]* %A, i32 0, i32 5005
28:   %16 = load i32* %15, align 4, !tbaa !5
9:   %scevgep2 = getelementptr [10000 x i32]* %A, i32 0, i32 %3, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
10:   %4 = add i32 %1, 103, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
11:   %scevgep3 = getelementptr [10000 x i32]* %A, i32 0, i32 %4, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
12:   %5 = add i32 %1, 5, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
13:   %scevgep4 = getelementptr [10000 x i32]* %A, i32 0, i32 %5, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
14:   %6 = add i32 %1, 102, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
15:   %scevgep5 = getelementptr [10000 x i32]* %A, i32 0, i32 %6, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
16:   %7 = add i32 %1, 4, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
17:   %scevgep6 = getelementptr [10000 x i32]* %A, i32 0, i32 %7, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
18:   %8 = add i32 %1, 101, !legup.pipeline.start_time !2, !legup.pipeline.avail_time !2, !legup.pipeline.stage !3
19:   %scevgep7 = getelementptr [10000 x i32]* %A, i32 0, i32 %8, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
20:   %scevgep8 = getelementptr [10000 x i32]* %A, i32 0, i32 %9, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !4, !legup.pipeline.stage !3
22:   %11 = load i32* %scevgep6, align 4, !tbaa !5, !legup.pipeline.start_time !4, !legup.pipeline.avail_time !9, !legup.pipeline.stage !3
23:   %12 = load i32* %scevgep4, align 4, !tbaa !5, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
24:   %13 = load i32* %scevgep2, align 4, !tbaa !5, !legup.pipeline.start_time !9, !legup.pipeline.avail_time !12, !legup.pipeline.stage !3
25:   %indvar.next = add i32 %indvar, 1, !legup.pipeline.start_time !3, !legup.pipeline.avail_time !3, !legup.pipeline.stage !3
Memory: Int -> Value* mapping
1: @.str = private unnamed_addr constant [6 x i8] c"loop1\00", align 1
3:   %A = alloca [10000 x i32], align 4
digraph "typ_loop.bc" {
    1 [label="#1",color=blue,style=solid];
    2 [label=".str",color=blue,style=solid];
    3 [label="#3",color=blue,style=solid];
    4 [label="A",color=blue,style=solid];
    5 [label="unknown",color=blue,style=solid];
    6 [label="unknown",color=blue,style=solid];
    7 [label="scevgep",color=blue,style=solid];
    8 [label="unknown",color=blue,style=solid];
    9 [label="scevgep2",color=blue,style=solid];
    10 [label="unknown",color=blue,style=solid];
    11 [label="scevgep3",color=blue,style=solid];
    12 [label="unknown",color=blue,style=solid];
    13 [label="scevgep4",color=blue,style=solid];
    14 [label="unknown",color=blue,style=solid];
    15 [label="scevgep5",color=blue,style=solid];
    16 [label="unknown",color=blue,style=solid];
    17 [label="scevgep6",color=blue,style=solid];
    18 [label="unknown",color=blue,style=solid];
    19 [label="scevgep7",color=blue,style=solid];
    20 [label="scevgep8",color=blue,style=solid];
    21 [label="unknown",color=blue,style=solid];
    22 [label="unknown",color=blue,style=solid];
    23 [label="unknown",color=blue,style=solid];
    24 [label="unknown",color=blue,style=solid];
    25 [label="indvar.next",color=blue,style=solid];
    26 [label="indvar",color=blue,style=solid];
    27 [label="unknown",color=blue,style=solid];
    28 [label="unknown",color=blue,style=solid];
    3 -> 21;
    3 -> 22;
    3 -> 23;
    3 -> 24;
    3 -> 28;
    4 -> 7;
    4 -> 9;
    4 -> 11;
    4 -> 13;
    4 -> 15;
    4 -> 17;
    4 -> 19;
    4 -> 20;
    4 -> 27;
    6 -> 5;
    6 -> 8;
    6 -> 10;
    6 -> 12;
    6 -> 14;
    6 -> 16;
    6 -> 18;
    26 -> 25;
    pts2 [label="#1",color=red,style=dashed,shape=box];
    2 -> pts2 [color=red,style=dashed];
    pts4 [label="#3",color=red,style=dashed,shape=box];
    4 -> pts4 [color=red,style=dashed];
    pts7 [label="#3",color=red,style=dashed,shape=box];
    7 -> pts7 [color=red,style=dashed];
    pts9 [label="#3",color=red,style=dashed,shape=box];
    9 -> pts9 [color=red,style=dashed];
    pts11 [label="#3",color=red,style=dashed,shape=box];
    11 -> pts11 [color=red,style=dashed];
    pts13 [label="#3",color=red,style=dashed,shape=box];
    13 -> pts13 [color=red,style=dashed];
    pts15 [label="#3",color=red,style=dashed,shape=box];
    15 -> pts15 [color=red,style=dashed];
    pts17 [label="#3",color=red,style=dashed,shape=box];
    17 -> pts17 [color=red,style=dashed];
    pts19 [label="#3",color=red,style=dashed,shape=box];
    19 -> pts19 [color=red,style=dashed];
    pts20 [label="#3",color=red,style=dashed,shape=box];
    20 -> pts20 [color=red,style=dashed];
    pts27 [label="#3",color=red,style=dashed,shape=box];
    27 -> pts27 [color=red,style=dashed];
}
%10 -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
<badref> -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
%11 -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
<badref> -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
%12 -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
<badref> -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
%13 -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
<badref> -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
%16 -> { 
	Addr: %A
		RAM: main_0_A
			Adding Local RAM: main_0_A to Fct: @main
}
Final memory allocation:
Global Memories:
Local Memories:
	RAM: main_0_A Function: main
